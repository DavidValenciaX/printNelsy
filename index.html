<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asistente de impresión de Imágenes</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
</head>

<body>
    <div id="main-content">
        <div class="main-container">
            <!-- Left Sidebar -->
            <div class="button-container">
                <!-- File Operations -->
                <div class="button-group">
                    <div class="group-title">Archivo</div>
                    <label for="imageLoader" class="control-button">
                        <i class="fas fa-upload button-icon"></i> Cargar imágenes
                    </label>
                    <input type="file" id="imageLoader" accept="image/*" multiple aria-label="Cargar imágenes" />
                    <button type="button" id="printButton" class="control-button">
                        <i class="fas fa-print button-icon"></i> Imprimir
                    </button>
                </div>

                <!-- Paper Size -->
                <div class="button-group">
                    <div class="group-title">Tamaño de Papel</div>
                    <button type="button" class="size-button" id="cartaButton">
                        <i class="fas fa-file button-icon"></i> CARTA
                    </button>
                    <button type="button" class="size-button" id="oficioButton">
                        <i class="fas fa-file-alt button-icon"></i> OFICIO
                    </button>
                    <button type="button" class="size-button" id="a4Button">
                        <i class="fas fa-file-invoice button-icon"></i> A4
                    </button>
                </div>

                <!-- Orientation -->
                <div class="button-group">
                    <div class="group-title">Orientación</div>
                    <button type="button" class="orientation-button" id="verticalButton">
                        <i class="fas fa-file button-icon"></i> Vertical
                    </button>
                    <button type="button" class="orientation-button" id="horizontalButton">
                        <i class="fas fa-file rotate-90 button-icon"></i> Horizontal
                    </button>
                </div>
            </div>

            <!-- Canvas -->
            <div id="canvas-container">
                <canvas id="canvas"></canvas>
            </div>

            <!-- Right Sidebar -->
            <div class="button-container">
                <!-- Image Operations -->
                <div class="button-group">
                    <div class="group-title">Operaciones de Imagen</div>
                    <button type="button" id="cropButton" class="control-button">
                        <i class="fas fa-crop button-icon"></i> Recortar imagen
                    </button>
                    <button type="button" id="confirmCrop" class="control-button">
                        <i class="fas fa-check button-icon"></i> Confirmar
                    </button>
                    <button type="button" id="cancelCrop" class="control-button">
                        <i class="fas fa-times button-icon"></i> Cancelar
                    </button>
                    <button type="button" id="grayScaleBtn" class="control-button">
                        <i class="fas fa-adjust button-icon"></i> Convertir a B/N
                    </button>
                    <button type="button" id="resetImageButton" class="control-button">
                        <i class="fas fa-undo button-icon"></i> Restablecer imagen
                    </button>
                </div>

                <!-- Transform Controls -->
                <div class="button-group">
                    <div class="group-title">Transformación</div>
                    <button type="button" id="rotateButton+90" class="control-button">
                        <i class="fas fa-redo button-icon"></i> Girar 90° derecha
                    </button>
                    <button type="button" id="rotateButton-90" class="control-button">
                        <i class="fas fa-undo button-icon"></i> Girar 90° izquierda
                    </button>
                    <div class="control-group">
                        <input type="checkbox" id="rotateControl" />
                        <label for="rotateControl">Permitir rotación libre</label>
                    </div>
                </div>

                <!-- Size Controls -->
                <div class="button-group">
                    <div class="group-title">Tamaño</div>
                    <button type="button" id="scaleUp" class="control-button">
                        <i class="fas fa-expand button-icon"></i> Ampliar imagen
                    </button>
                    <button type="button" id="scaleDown" class="control-button">
                        <i class="fas fa-compress button-icon"></i> Reducir imagen
                    </button>
                    <input type="number" id="widthInput" placeholder="Ancho en cm" step="0.1" />
                    <input type="number" id="heightInput" placeholder="Alto en cm" step="0.1" />
                    <button type="button" id="setSizeButton" class="control-button">
                        <i class="fas fa-ruler button-icon"></i> Establecer tamaño
                    </button>
                </div>

                <!-- Position Controls -->
                <div class="button-group">
                    <div class="group-title">Posición</div>
                    <button type="button" id="centerVerticallyBtn" class="control-button">
                        <i class="fas fa-arrows-alt-v button-icon"></i> Centrar vertical
                    </button>
                    <button type="button" id="centerHorizontallyBtn" class="control-button">
                        <i class="fas fa-arrows-alt-h button-icon"></i> Centrar horizontal
                    </button>
                    <button type="button" id="arrangeBtn" class="control-button">
                        <i class="fas fa-th button-icon"></i> Re-Ordenar imágenes
                    </button>
                </div>

                <!-- Danger Zone -->
                <div class="button-group">
                    <div class="group-title">Eliminar</div>
                    <button type="button" id="deleteButton" class="control-button danger-button">
                        <i class="fas fa-trash button-icon"></i> Eliminar imagen
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="zoom-controls">
        <button type="button" class="zoom-btn" onclick="zoomIn()" title="Aumentar zoom">
            <i class="fas fa-search-plus"></i>
        </button>
        <button type="button" class="zoom-btn" onclick="zoomOut()" title="Reducir zoom">
            <i class="fas fa-search-minus"></i>
        </button>
    </div>

    <script>

        let currentZoom = 1;
        const zoomFactor = 0.1;
        const maxZoom = 2;
        const minZoom = 0.5;

        function zoomIn() {
            if (currentZoom < maxZoom) {
                currentZoom += zoomFactor;
                applyZoom();
            }
        }

        function zoomOut() {
            if (currentZoom > minZoom) {
                currentZoom -= zoomFactor;
                applyZoom();
            }
        }

        function applyZoom() {
            document.getElementById('main-content').style.transform = `scale(${currentZoom})`;
        }

        const canvasElement = document.getElementById('canvas');
        let canvas = new fabric.Canvas('canvas');
        const imageLoader = document.getElementById('imageLoader');
        const deleteButton = document.getElementById('deleteButton');
        const printButton = document.getElementById('printButton');
        const cartaButton = document.getElementById('cartaButton');
        const oficioButton = document.getElementById('oficioButton');
        const a4Button = document.getElementById('a4Button');
        const verticalButton = document.getElementById('verticalButton');
        const horizontalButton = document.getElementById('horizontalButton');
        const rotateButton_p90 = document.getElementById('rotateButton+90');
        const rotateButton_n90 = document.getElementById('rotateButton-90');
        const resetImageButton = document.getElementById('resetImageButton');
        const arrangeBtn = document.getElementById('arrangeBtn');
        const cropButton = document.getElementById('cropButton');
        const confirmCropBtn = document.getElementById('confirmCrop');
        const cancelCropBtn = document.getElementById('cancelCrop');
        const rotateCheckbox = document.getElementById('rotateControl');
        const grayScaleBtn = document.getElementById('grayScaleBtn');
        const scaleUpBtn = document.getElementById('scaleUp');
        const scaleDownBtn = document.getElementById('scaleDown');
        const centerVerticallyBtn = document.getElementById('centerVerticallyBtn');
        const centerHorizontallyBtn = document.getElementById('centerHorizontallyBtn');
        const setSizeBtn = document.getElementById('setSizeButton');

        const dpi = 300;
        const marginInches = 0.2;
        const marginPixels = marginInches * dpi;
        const paperSizes = {
            carta: { width: 8.5 * dpi, height: 11 * dpi },
            oficio: { width: 8.5 * dpi, height: 13 * dpi },
            a4: { width: 8.27 * dpi, height: 11.69 * dpi }
        };

        let currentSize = 'carta';
        let isVertical = true;
        let marginRect;

        let cropRect = null;
        let activeImage = null;
        let isCropping = false;
        let inactivatedObjects = [];

        function setImageSizeInCm() {
            const activeObject = canvas.getActiveObject();
            if (!activeObject || activeObject.type !== 'image') {
                alert('Seleccione primero una imagen.');
                return;
            }

            // Obtener los valores de ancho y alto ingresados
            const widthInputValue = document.getElementById('widthInput').value;
            const heightInputValue = document.getElementById('heightInput').value;

            // Se utilizan escalas separadas para ancho y alto
            const canvasScaleX = canvas.getWidth() / paperSizes[currentSize].width;
            const canvasScaleY = canvas.getHeight() / paperSizes[currentSize].height;

            let updated = false;

            // Actualizar ancho si se ingresa valor válido
            if (widthInputValue) {
                const cmWidth = parseFloat(widthInputValue);
                if (isNaN(cmWidth) || cmWidth <= 0) {
                    alert('Introduzca una anchura válida en centímetros.');
                    return;
                }
                const targetWidthPixels = (cmWidth / 2.54) * dpi;
                const newScaleX = (targetWidthPixels * canvasScaleX) / activeObject.width;
                activeObject.scaleX = newScaleX;
                updated = true;
            }

            // Actualizar alto si se ingresa valor válido
            if (heightInputValue) {
                const cmHeight = parseFloat(heightInputValue);
                if (isNaN(cmHeight) || cmHeight <= 0) {
                    alert('Introduzca una altura válida en centímetros.');
                    return;
                }
                const targetHeightPixels = (cmHeight / 2.54) * dpi;
                const newScaleY = (targetHeightPixels * canvasScaleY) / activeObject.height;
                activeObject.scaleY = newScaleY;
                updated = true;
            }

            if (!updated) {
                alert('Introduzca al menos una dimensión válida.');
                return;
            }

            activeObject.setCoords();
            canvas.renderAll();
        }

        function centerVertically() {
            const activeObject = canvas.getActiveObject();
            if (!activeObject) return;

            const canvasHeight = canvas.getHeight();

            // Calculate vertical center position
            const centerY = canvasHeight / 2;

            // Set new position
            activeObject.set({
                top: centerY
            });

            canvas.renderAll();
        }

        function centerHorizontally() {
            const activeObject = canvas.getActiveObject();
            if (!activeObject) return;

            const canvasWidth = canvas.getWidth();

            // Calculate horizontal center position
            const centerX = canvasWidth / 2;

            // Set new position
            activeObject.set({
                left: centerX
            });

            canvas.renderAll();
        }

        const SCALE_FACTOR = 0.05;

        function disableOtherObjects() {
            canvas.getObjects().forEach(obj => {
                if (obj !== cropRect && obj !== marginRect) {
                    inactivatedObjects.push({
                        object: obj,
                        originalOpacity: obj.opacity
                    });

                    if (obj !== activeImage) {
                        obj.set({
                            opacity: 0.3,
                        });
                    }
                    obj.set({
                        selectable: false,
                        evented: false
                    });
                }
            });
            canvas.requestRenderAll();
        }

        // Modify the restore function
        function restoreOtherObjects() {
            inactivatedObjects.forEach(item => {
                // Don't restore properties for background
                if (item.object.name !== 'background') {
                    item.object.set({
                        opacity: item.originalOpacity,
                        selectable: true,
                        evented: true
                    });
                }
            });
            inactivatedObjects = [];
            canvas.requestRenderAll();
        }

        function enterCropMode(imgObject) {
            activeImage = imgObject;
            isCropping = true;

            // Get image bounding rect
            const bounds = imgObject.getBoundingRect();

            // Create crop rect using bounds
            cropRect = new fabric.Rect({
                left: bounds.left,
                top: bounds.top,
                width: bounds.width,
                height: bounds.height,
                fill: 'transparent',
                stroke: '#000',
                strokeWidth: 1,
                strokeDashArray: [5, 5],
                absolutePositioned: true,
                transparentCorners: false,
                cornerColor: 'DodgerBlue',
                cornerStyle: 'circle',
                cornerSize: 12,
                cornerStrokeColor: 'Blue'
            });

            canvas.add(cropRect);

            // Bring both objects to front
            imgObject.bringToFront();
            cropRect.bringToFront();

            // Disable other objects
            disableOtherObjects();

            canvas.setActiveObject(cropRect);

            // Show crop control buttons
            confirmCropBtn.style.display = 'inline';
            cancelCropBtn.style.display = 'inline';
            cropButton.style.display = 'none';
        }

        // Add this global variable at the top of your script
        let canvasBackground = null;

        // Modify the background creation function
        function createCanvasBackground() {
            // Remove existing background if it exists
            if (canvasBackground) {
                canvas.remove(canvasBackground);
            }

            canvasBackground = new fabric.Rect({
                left: 0,
                top: 0,
                width: canvas.width,
                height: canvas.height,
                fill: 'white',
                selectable: false,
                evented: false,
                name: 'background' // Add an identifier
            });

            canvas.add(canvasBackground);
            canvas.sendToBack(canvasBackground);
        }

        function confirmCrop() {
            if (!isCropping || !cropRect || !activeImage) return;

            // Get the cropping rect and original image's ID
            const rect = cropRect;
            const img = activeImage;
            const originalId = img.id; // Save original ID

            // Set the crop rect stroke to transparent so that it doesn't bleed into the final image
            rect.set('stroke', 'transparent');

            // Create a background to fill the canvas with white color
            createCanvasBackground();

            // Hide other objects
            canvas.getObjects().forEach(obj => {
                if (obj !== cropRect && obj !== marginRect && obj !== activeImage && obj !== canvasBackground) {
                    obj.set({
                        opacity: 0,
                    });
                }
            });

            // Create new cropped image
            const cropped = new Image();
            cropped.src = canvas.toDataURL({
                left: rect.left,
                top: rect.top,
                width: rect.width * rect.scaleX,
                height: rect.height * rect.scaleY
            });

            cropped.onload = function () {
                // Remove old image and crop rect
                canvas.remove(img);
                canvas.remove(rect);

                // Create and add new cropped image
                const newImage = new fabric.Image(cropped);
                newImage.set({
                    id: originalId, // Transfer the original ID
                    left: rect.left,
                    top: rect.top,
                });

                // Set rotation control visibility based on checkbox state
                newImage.setControlsVisibility({
                    mtr: rotateCheckbox.checked
                });

                newImage.setCoords();
                canvas.add(newImage);
                canvas.renderAll();
            };

            exitCropMode();
        }

        function exitCropMode() {
            if (cropRect) {
                canvas.remove(cropRect);
                cropRect = null;
            }

            isCropping = false;
            activeImage = null;

            // Restore other objects
            restoreOtherObjects();

            // Hide crop control buttons
            confirmCropBtn.style.display = 'none';
            cancelCropBtn.style.display = 'none';
            cropButton.style.display = 'inline';
        }

        function deactivateObjects(event) {
            const canvasElement = canvas.getElement();
            const isOnCanvasElement = event.target === canvasElement;
            const isOnFabricControls = event.target.classList.contains('canvas-container') ||
                event.target.classList.contains('upper-canvas') ||
                event.target.classList.contains('lower-canvas');
            const isOnButton = event.target.tagName === 'BUTTON' ||
                event.target.closest('button') !== null;

            const isOnCheckbox = event.target.tagName === 'INPUT' &&
                event.target.type === 'checkbox';

            const isOnInputNumber = event.target.tagName === 'INPUT' &&
                event.target.type === 'number';

            const isOnCheckBoxLabel = event.target.tagName === 'LABEL' &&
                event.target.htmlFor === 'rotateControl';

            if (!isOnCanvasElement && !isOnFabricControls && !isOnButton && !isOnCheckbox && !isOnCheckBoxLabel && !isOnInputNumber) {
                canvas.discardActiveObject();
                canvas.requestRenderAll();
            }
        }

        function degToRad(degrees) {
            return degrees * (Math.PI / 180);
        }

        function radToDeg(radians) {
            return radians * (180 / Math.PI);
        }

        function resizeCanvas(size, orientation = isVertical) {
            // Store current canvas state
            const images = canvas.getObjects().filter(obj => obj.type === 'image');
            const currentLayout = lastLayout || (images.length <= 2 ? 'cols' : 'rows');
            const currentDirection = 'forward';

            // Remove all images from canvas
            images.forEach(img => canvas.remove(img));

            // Update canvas dimensions
            currentSize = size;
            isVertical = orientation;
            const scale = 0.3;
            let width = paperSizes[size].width;
            let height = paperSizes[size].height;

            if (!isVertical) {
                [width, height] = [height, width];
            }

            canvas.setWidth(width * scale);
            canvas.setHeight(height * scale);

            // Update margin rectangle
            if (marginRect) {
                canvas.remove(marginRect);
            }

            marginRect = new fabric.Rect({
                width: width * scale - (2 * marginPixels * scale),
                height: height * scale - (2 * marginPixels * scale),
                left: marginPixels * scale,
                top: marginPixels * scale,
                fill: 'transparent',
                stroke: 'gray',
                strokeWidth: 1,
                strokeDashArray: [5, 5],
                selectable: false,
                evented: false
            });

            canvas.add(marginRect);

            // Re-arrange images with same layout and direction
            if (images.length > 0) {
                arrangeImages(images, currentLayout, currentDirection);
            }

            canvas.renderAll();
        }

        function changeOrientation(vertical) {
            resizeCanvas(currentSize, vertical);
        }

        // Add this at the top with other variables
        const originalImages = {};

        function handleImageUpload(e) {
            const files = e.target.files;
            const loadedImages = [];
            let processedCount = 0;

            for (const element of files) {
                const file = element;
                const reader = new FileReader();
                reader.onload = function (event) {
                    fabric.Image.fromURL(event.target.result, function (img) {
                        // Asignar un id único permanente si no lo tiene
                        if (!img.id) {
                            const uniqueId = `image-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                            img.id = uniqueId;
                        }
                        // Guardar la URL de origen
                        img.originalUrl = event.target.result;

                        img.setControlsVisibility({
                            mtr: rotateCheckbox.checked
                        });

                        loadedImages.push(img);
                        processedCount++;

                        if (processedCount === files.length) {
                            // Primero, se organiza el layout de las imágenes
                            if (files.length <= 2) {
                                arrangeImages(loadedImages, 'cols', 'forward');
                                lastLayout = 'cols';
                                lastDirection = 'forward';
                            } else {
                                arrangeImages(loadedImages, 'rows', 'forward');
                                lastLayout = 'rows';
                                lastDirection = 'forward';
                            }

                            // Luego, se guardan los datos originales ya con sus valores de top, left, scaleX y scaleY actualizados
                            loadedImages.forEach(img => {
                                originalImages[img.id] = {
                                    url: img.originalUrl,
                                    width: img.width,
                                    height: img.height,
                                    scaleX: img.scaleX,
                                    scaleY: img.scaleY,
                                    angle: img.angle,
                                    left: img.left,
                                    top: img.top
                                };
                            });

                            // Seleccionar automáticamente si solo hay una imagen
                            if (files.length === 1) {
                                canvas.discardActiveObject();
                                canvas.setActiveObject(loadedImages[0]);
                                canvas.renderAll();
                            }
                        }
                    });
                }
                reader.readAsDataURL(file);
            }
        }

        // Función para redondear a un número específico de decimales
        function roundToDecimals(value, decimals) {
            return Number(value.toFixed(decimals));
        }

        function arrangeImages(images, orientation, order = 'forward') {
            const count = images.length;
            let marginAdjustment = count <= 2 ? 100 : 20;
            const margin = marginWidth + marginAdjustment;

            // Crear copia y ordenar según order
            const sortedImages = [...images];
            if (order === 'reverse') {
                sortedImages.reverse();
            }

            let cols, rows;
            if (orientation === 'rows') {
                cols = Math.ceil(Math.sqrt(count));
                rows = Math.ceil(count / cols);
            } else if (orientation === 'cols') {
                rows = Math.ceil(Math.sqrt(count));
                cols = Math.ceil(count / rows);
            }

            const cellWidth = (canvas.width - margin * 2) / cols;
            const cellHeight = (canvas.height - margin * 2) / rows;

            sortedImages.forEach((img, index) => {
                // Determinar fila y columna sin alterar el id permanente
                let row, col;
                if (orientation === 'rows') {
                    row = Math.floor(index / cols);
                    col = index % cols;
                } else if (orientation === 'cols') {
                    col = Math.floor(index / rows);
                    row = index % rows;
                }

                let realImageWidth = img.width * img.scaleX;
                let realImageHeight = img.height * img.scaleY;
                let bounds = img.getBoundingRect();

                let roundedBoundsWidth = roundToDecimals(bounds.width, 2);
                let roundedImageWidth = roundToDecimals(realImageWidth, 2);
                const offsetWidthImageBound = roundToDecimals(roundedBoundsWidth - roundedImageWidth, 2);

                let roundedBoundsHeight = roundToDecimals(bounds.height, 2);
                let roundedImageHeight = roundToDecimals(realImageHeight, 2);
                const offsetHeightImageBound = roundToDecimals(roundedBoundsHeight - roundedImageHeight, 2);

                const scaleFactor = Math.min(
                    (cellWidth - margin - offsetWidthImageBound) / img.width,
                    (cellHeight - margin - offsetHeightImageBound) / img.height
                );

                img.scale(scaleFactor);
                img.set({
                    left: margin + col * cellWidth + cellWidth / 2,
                    top: margin + row * cellHeight + cellHeight / 2,
                    originX: 'center',
                    originY: 'center'
                });

                // Se mantiene originalImages intacto con la información original
                canvas.add(img);
            });

            canvas.renderAll();
        }

        // Reset active image to its original state
        function resetActiveImage() {
            const activeObject = canvas.getActiveObject();
            if (!activeObject || !activeObject.id || !originalImages[activeObject.id]) {
                alert('Por favor seleccione una imagen para restablecer');
                return;
            }

            const original = originalImages[activeObject.id];

            fabric.Image.fromURL(original.url, function (img) {
                // Apply original properties to new image
                img.set({
                    id: activeObject.id,
                    scaleX: original.scaleX,
                    scaleY: original.scaleY,
                    angle: 0,
                    left: original.left,
                    top: original.top,
                    originX: 'center',
                    originY: 'center'
                });

                // Replace old image with new one
                canvas.remove(activeObject);
                canvas.add(img);
                canvas.setActiveObject(img);
                canvas.renderAll();
            });
        }

        function printCanvas() {

            // Store original opacity
            const originalOpacity = marginRect.opacity;

            // Make margin invisible for printing
            marginRect.opacity = 0;
            canvas.renderAll();

            const dataUrl = canvas.toDataURL({
                format: 'png',
                quality: 1,
                multiplier: 1 / canvas.getZoom()
            });

            const windowContent = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Imprimir Canvas</title>
                    <meta name="viewport" content="width=device-width, initial-scale=1">
                    <style>
                        @page {
                            margin: 0;
                            size: auto;
                        }
                        body {
                            margin: 0;
                            padding: 0;
                        }
                        img {
                            width: 100%;
                            height: auto;
                            display: block;
                            margin: 0;
                        }
                    </style>
                </head>
                <body>
                    <img src="${dataUrl}">
                </body>
                </html>`;

            const printWin = window.open('', '', 'width=800,height=600');
            printWin.document.open();
            printWin.document.write(windowContent);
            printWin.document.close();
            printWin.setTimeout(function () {
                printWin.focus();
                printWin.print();
                printWin.close();
                marginRect.opacity = originalOpacity;
                canvas.renderAll();
            }, 250);
        }

        function rotateImage(deg) {
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                activeObject.rotate((activeObject.angle + deg) % 360);

                activeObject.setCoords();

                constrainObjectToMargin(activeObject, marginRect);

                canvas.renderAll();
            }
        }

        function deleteActiveObject() {
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                canvas.remove(activeObject);
                canvas.renderAll();
            }
        }

        function convertToGrayscale() {
            const activeObject = canvas.getActiveObject();
            if (!activeObject) {
                alert('Seleccione primero una imagen.');
                return;
            }

            // Apply grayscale filter
            activeObject.filters.push(new fabric.Image.filters.Grayscale());

            // Apply the filters and re-render
            activeObject.applyFilters();
            canvas.renderAll();
        }

        function calculateDistance(x1, y1, x2, y2) {
            // Calculate the difference in x and y coordinates
            const dx = x2 - x1;
            const dy = y2 - y1;

            // Use Pythagorean theorem to calculate distance
            return Math.sqrt(dx * dx + dy * dy);
        }

        function scaleUp() {
            const activeObject = canvas.getActiveObject();
            if (!activeObject) return;

            const currentScaleX = activeObject.scaleX;
            const currentScaleY = activeObject.scaleY;
            activeObject.scaleX = currentScaleX + SCALE_FACTOR;
            activeObject.scaleY = currentScaleY + SCALE_FACTOR;
            constrainObjectToMargin(activeObject, marginRect);
            canvas.renderAll();
        }

        function scaleDown() {
            const activeObject = canvas.getActiveObject();
            if (!activeObject) return;

            const currentScaleX = activeObject.scaleX;
            const currentScaleY = activeObject.scaleY;
            // Prevent scaling below 0.1 to avoid object disappearing
            if (currentScaleX > 0.1 && currentScaleY > 0.1) {
                activeObject.scaleX = currentScaleX - SCALE_FACTOR;
                activeObject.scaleY = currentScaleY - SCALE_FACTOR;
                constrainObjectToMargin(activeObject, marginRect);
                canvas.renderAll();
            }
        }

        let lastLayout = 'rows';    // Track layout type (rows/cols)
        let lastDirection = 'forward'; // Track direction (forward/reverse)

        function selectArrangeImageLayout() {
            // 1. Get all current images
            const images = canvas.getObjects().filter(obj => obj.type === 'image');

            // 2. Remove existing images from canvas
            images.forEach(img => canvas.remove(img));

            // 3. Determine next arrangement state
            if (lastLayout === 'rows' && lastDirection === 'forward') {
                arrangeImages(images, 'rows', 'reverse');
                lastLayout = 'rows';
                lastDirection = 'reverse';
            } else if (lastLayout === 'rows' && lastDirection === 'reverse') {
                arrangeImages(images, 'cols', 'forward');
                lastLayout = 'cols';
                lastDirection = 'forward';
            } else if (lastLayout === 'cols' && lastDirection === 'forward') {
                arrangeImages(images, 'cols', 'reverse');
                lastLayout = 'cols';
                lastDirection = 'reverse';
            } else {
                arrangeImages(images, 'rows', 'forward');
                lastLayout = 'rows';
                lastDirection = 'forward';
            }

            canvas.renderAll();
        }

        cartaButton.addEventListener('click', () => resizeCanvas('carta'));
        oficioButton.addEventListener('click', () => resizeCanvas('oficio'));
        a4Button.addEventListener('click', () => resizeCanvas('a4'));
        verticalButton.addEventListener('click', () => changeOrientation(true));
        horizontalButton.addEventListener('click', () => changeOrientation(false));

        imageLoader.addEventListener('change', handleImageUpload);
        resetImageButton.addEventListener('click', resetActiveImage);
        printButton.addEventListener('click', printCanvas);
        grayScaleBtn.addEventListener('click', convertToGrayscale);
        rotateButton_p90.addEventListener('click', () => rotateImage(90));
        rotateButton_n90.addEventListener('click', () => rotateImage(270));
        centerVerticallyBtn.addEventListener('click', centerVertically);
        centerHorizontallyBtn.addEventListener('click', centerHorizontally);
        deleteButton.addEventListener('click', deleteActiveObject);
        confirmCropBtn.addEventListener('click', confirmCrop);
        cancelCropBtn.addEventListener('click', exitCropMode);
        scaleUpBtn.addEventListener('click', scaleUp);
        scaleDownBtn.addEventListener('click', scaleDown);
        arrangeBtn.addEventListener('click', selectArrangeImageLayout);
        setSizeBtn.addEventListener('click', setImageSizeInCm);

        rotateCheckbox.addEventListener('change', function (e) {
            canvas.getObjects().forEach(obj => {
                if (obj.type === 'image') {
                    obj.setControlsVisibility({
                        mtr: this.checked
                    });
                }
            });
            canvas.requestRenderAll();
        });

        cropButton.addEventListener('click', function () {
            const activeObject = canvas.getActiveObject();
            if (!activeObject || activeObject.type !== 'image') return;

            enterCropMode(activeObject);
        });

        // Add keyboard delete support
        document.addEventListener('keydown', function (event) {
            if (event.key === 'Delete') {
                deleteActiveObject();
            }
        });

        document.body.addEventListener('click', () => deactivateObjects(event));

        fabric.Object.prototype.transparentCorners = false;
        fabric.Object.prototype.cornerColor = 'limegreen';
        fabric.Object.prototype.cornerStrokeColor = 'black';
        fabric.Object.prototype.cornerStyle = 'rect';
        fabric.Object.prototype.cornerSize = 12;
        const controls = fabric.Object.prototype.controls;
        const rotateControls = controls.mtr;
        rotateControls.visible = false;

        function constrainObjectToMargin(obj, marginRect) {
            obj.setCoords();

            let objPoints = [obj.aCoords.tl, obj.aCoords.tr, obj.aCoords.br, obj.aCoords.bl];
            let marginRight = marginRect.left + marginRect.width;
            let marginBottom = marginRect.top + marginRect.height;

            let offsetX = 0, offsetY = 0;

            objPoints.forEach(function (point) {
                if (point.x < marginRect.left) {
                    offsetX = Math.max(offsetX, marginRect.left - point.x);
                }
                if (point.x > marginRight) {
                    offsetX = Math.min(offsetX, marginRight - point.x);
                }
                if (point.y < marginRect.top) {
                    offsetY = Math.max(offsetY, marginRect.top - point.y);
                }
                if (point.y > marginBottom) {
                    offsetY = Math.min(offsetY, marginBottom - point.y);
                }
            });

            if (offsetX !== 0 || offsetY !== 0) {
                obj.left += offsetX;
                obj.top += offsetY;
                obj.setCoords();
            }

            return obj;
        }

        canvas.on('object:moving', function (e) {
            constrainObjectToMargin(e.target, marginRect);
        });

        let isMouseDown = false;

        canvas.on('mouse:down', function () {
            isMouseDown = true;
        });

        canvas.on('mouse:up', function () {
            isMouseDown = false;
        });

        // From here, the code for rotating restrictions is added

        let clockwise = false;

        let accumulatedRestrictedAngle = 0;

        let angleDiff = 0;

        canvas.on('object:rotating', function (event) {
            const obj = event.target;
            obj.setCoords();

            // Initialize accumulated angle if not exists
            if (typeof obj.previousAngle === 'undefined') {
                obj.previousAngle = 0;
            }

            // Get current angle and calculate direction
            const currentAngle = obj.angle;

            // Detect direction and full rotations
            angleDiff = currentAngle - obj.previousAngle;

            // Handle angle wrap-around
            if (angleDiff > 270) {
                angleDiff -= 360;  // Counter-clockwise wrap from 0 to 359
            } else if (angleDiff < -270) {
                angleDiff += 360;  // Clockwise wrap from 359 to 0
            }

            clockwise = angleDiff > 0;

            // Store current angle for next comparison
            obj.previousAngle = currentAngle;

            let TOP = obj.top;
            let LEFT = obj.left;

            let TL = obj.aCoords.tl;
            let TR = obj.aCoords.tr;
            let BL = obj.aCoords.bl;
            let BR = obj.aCoords.br;

            let realObjectWidth = obj.width * obj.scaleX;
            let realObjectHeight = obj.height * obj.scaleY;

            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

            let complementDiagAngle = Math.PI / 2 - diagAngle;

            // Calculate margins from canvas edges
            const leftMargin = marginRect.left;
            const rightMargin = marginRect.left + marginRect.width;
            const topMargin = marginRect.top;
            const bottomMargin = marginRect.top + marginRect.height;

            // This function restricts the rotation of the object if it is exceeding the margins while it is rotating
            function checkRotating(point) {
                if (!isMouseDown) {
                    activeRestriction = null;
                }

                if (!activeRestriction) {
                    accumulatedRestrictedAngle = 0;
                    if (isMouseDown && TR.x > rightMargin && clockwise) {
                        activeRestriction = 'TR_RIGHT_CW';
                    } else if (isMouseDown && BR.x > rightMargin && !clockwise) {
                        activeRestriction = 'BR_RIGHT_CCW';
                    } else if (isMouseDown && TL.x > rightMargin && clockwise) {
                        activeRestriction = 'TL_RIGHT_CW';
                    } else if (isMouseDown && TR.x > rightMargin && !clockwise) {
                        activeRestriction = 'TR_RIGHT_CCW';
                    } else if (isMouseDown && BL.x > rightMargin && clockwise) {
                        activeRestriction = 'BL_RIGHT_CW';
                    } else if (isMouseDown && TL.x > rightMargin && !clockwise) {
                        activeRestriction = 'TL_RIGHT_CCW';
                    } else if (isMouseDown && BR.x > rightMargin && clockwise) {
                        activeRestriction = 'BR_RIGHT_CW';
                    } else if (isMouseDown && BL.x > rightMargin && !clockwise) {
                        activeRestriction = 'BL_RIGHT_CCW';
                    } else if (isMouseDown && BR.y > bottomMargin && clockwise) {
                        activeRestriction = 'BR_BOTTOM_CW';
                    } else if (isMouseDown && BL.y > bottomMargin && !clockwise) {
                        activeRestriction = 'BL_BOTTOM_CCW';
                    } else if (isMouseDown && TR.y > bottomMargin && clockwise) {
                        activeRestriction = 'TR_BOTTOM_CW';
                    } else if (isMouseDown && BR.y > bottomMargin && !clockwise) {
                        activeRestriction = 'BR_BOTTOM_CCW';
                    } else if (isMouseDown && TL.y > bottomMargin && clockwise) {
                        activeRestriction = 'TL_BOTTOM_CW';
                    } else if (isMouseDown && TR.y > bottomMargin && !clockwise) {
                        activeRestriction = 'TR_BOTTOM_CCW';
                    } else if (isMouseDown && BL.y > bottomMargin && clockwise) {
                        activeRestriction = 'BL_BOTTOM_CW';
                    } else if (isMouseDown && TL.y > bottomMargin && !clockwise) {
                        activeRestriction = 'TL_BOTTOM_CCW';
                    } else if (isMouseDown && TL.x < leftMargin && !clockwise) {
                        activeRestriction = 'TL_LEFT_CCW';
                    } else if (isMouseDown && BL.x < leftMargin && clockwise) {
                        activeRestriction = 'BL_LEFT_CW';
                    } else if (isMouseDown && BL.x < leftMargin && !clockwise) {
                        activeRestriction = 'BL_LEFT_CCW';
                    } else if (isMouseDown && BR.x < leftMargin && clockwise) {
                        activeRestriction = 'BR_LEFT_CW';
                    } else if (isMouseDown && BR.x < leftMargin && !clockwise) {
                        activeRestriction = 'BR_LEFT_CCW';
                    } else if (isMouseDown && TR.x < leftMargin && clockwise) {
                        activeRestriction = 'TR_LEFT_CW';
                    } else if (isMouseDown && TR.x < leftMargin && !clockwise) {
                        activeRestriction = 'TR_LEFT_CCW';
                    } else if (isMouseDown && TL.x < leftMargin && clockwise) {
                        activeRestriction = 'TL_LEFT_CW';
                    } else if (isMouseDown && TL.y < topMargin && clockwise) {
                        activeRestriction = 'TL_TOP_CW';
                    } else if (isMouseDown && TR.y < topMargin && !clockwise) {
                        activeRestriction = 'TR_TOP_CCW';
                    } else if (isMouseDown && BL.y < topMargin && clockwise) {
                        activeRestriction = 'BL_TOP_CW';
                    } else if (isMouseDown && TL.y < topMargin && !clockwise) {
                        activeRestriction = 'TL_TOP_CCW';
                    } else if (isMouseDown && BR.y < topMargin && clockwise) {
                        activeRestriction = 'BR_TOP_CW';
                    } else if (isMouseDown && BL.y < topMargin && !clockwise) {
                        activeRestriction = 'BL_TOP_CCW';
                    } else if (isMouseDown && TR.y < topMargin && clockwise) {
                        activeRestriction = 'TR_TOP_CW';
                    } else if (isMouseDown && BR.y < topMargin && !clockwise) {
                        activeRestriction = 'BR_TOP_CCW';
                    }
                }

                switch (activeRestriction) {

                    case 'TR_RIGHT_CW': {
                        console.log("TR right margin rotating clockwise");
                        let co = rightMargin - obj.left;
                        let hypotenuse = calculateDistance(LEFT, TOP, TR.x, TR.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - complementDiagAngle;
                        let restrictedAngle = innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle >= 360) {
                            accumulatedRestrictedAngle -= 360;
                        }

                        if (accumulatedRestrictedAngle > 0) {

                            obj.angle = radToDeg(restrictedAngle);

                        } else if (BR.x > rightMargin && !clockwise) {

                            accumulatedRestrictedAngle = 0;

                            activeRestriction = 'BR_RIGHT_CCW';
                        }

                        break;
                    }

                    case 'BR_RIGHT_CCW': {
                        console.log("BR right margin rotating counterclockwise");
                        let co = rightMargin - obj.left;
                        let hypotenuse = calculateDistance(LEFT, TOP, BR.x, BR.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - complementDiagAngle;
                        let restrictedAngle = (2 * Math.PI) - innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle <= -360) {
                            accumulatedRestrictedAngle += 360;
                        }

                        if (accumulatedRestrictedAngle < 0) {

                            obj.angle = radToDeg(restrictedAngle);

                        } else if (TR.x > rightMargin && clockwise) {

                            accumulatedRestrictedAngle = 0;

                            activeRestriction = 'TR_RIGHT_CW';
                        }

                        break;

                    }

                    case 'TL_RIGHT_CW': {
                        console.log("TL right margin rotating clockwise");
                        let co = rightMargin - obj.left;
                        let hypotenuse = calculateDistance(LEFT, TOP, TL.x, TL.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - diagAngle;
                        let restrictedAngle = (Math.PI / 2) + innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle >= 360) {
                            accumulatedRestrictedAngle -= 360;
                        }

                        if (accumulatedRestrictedAngle > 0) {

                            obj.angle = radToDeg(restrictedAngle);

                        } else if (TR.x > rightMargin && !clockwise) {
                            accumulatedRestrictedAngle = 0;

                            activeRestriction = 'TR_RIGHT_CCW';
                        }
                        break;
                    }

                    case 'TR_RIGHT_CCW': {
                        console.log("TR right margin rotating counterclockwise");
                        let co = rightMargin - obj.left;
                        let hypotenuse = calculateDistance(LEFT, TOP, TR.x, TR.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - diagAngle;
                        let restrictedAngle = (Math.PI / 2) - innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle <= -360) {
                            accumulatedRestrictedAngle += 360;
                        }

                        if (accumulatedRestrictedAngle < 0) {

                            obj.angle = radToDeg(restrictedAngle);

                        } else if (TL.x > rightMargin && clockwise) {
                            accumulatedRestrictedAngle = 0;

                            activeRestriction = 'TL_RIGHT_CW';
                        }

                        break;
                    }

                    case 'BL_RIGHT_CW': {
                        console.log("BL right margin rotating clockwise");
                        let co = rightMargin - obj.left;
                        let hypotenuse = calculateDistance(LEFT, TOP, BL.x, BL.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - complementDiagAngle;
                        let restrictedAngle = Math.PI + innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle >= 360) {
                            accumulatedRestrictedAngle -= 360;
                        }

                        if (accumulatedRestrictedAngle > 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (TL.x > rightMargin && !clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'TL_RIGHT_CCW';
                        }
                        break;
                    }

                    case 'TL_RIGHT_CCW': {
                        console.log("TL right margin rotating counterclockwise");
                        let co = rightMargin - obj.left;
                        let hypotenuse = calculateDistance(LEFT, TOP, TL.x, TL.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - complementDiagAngle;
                        let restrictedAngle = Math.PI - innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle <= -360) {
                            accumulatedRestrictedAngle += 360;
                        }

                        if (accumulatedRestrictedAngle < 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (BL.x > rightMargin && clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'BL_RIGHT_CW';
                        }
                        break;
                    }

                    case 'BR_RIGHT_CW': {
                        console.log("BR right margin rotating clockwise");
                        let co = rightMargin - obj.left;
                        let hypotenuse = calculateDistance(LEFT, TOP, BR.x, BR.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - diagAngle;
                        let restrictedAngle = (3 * Math.PI / 2) + innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle >= 360) {
                            accumulatedRestrictedAngle -= 360;
                        }

                        if (accumulatedRestrictedAngle > 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (BL.x > rightMargin && !clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'BL_RIGHT_CCW';
                        }
                        break;
                    }

                    case 'BL_RIGHT_CCW': {
                        console.log("BL right margin rotating counterclockwise");
                        let co = rightMargin - obj.left;
                        let hypotenuse = calculateDistance(LEFT, TOP, BL.x, BL.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - diagAngle;
                        let restrictedAngle = (3 * Math.PI / 2) - innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle <= -360) {
                            accumulatedRestrictedAngle += 360;
                        }

                        if (accumulatedRestrictedAngle < 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (BR.x > rightMargin && clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'BR_RIGHT_CW';
                        }
                        break;
                    }

                    case 'BR_BOTTOM_CW': {
                        console.log("BR bottom margin rotating clockwise");
                        let co = bottomMargin - obj.top;
                        let hypotenuse = calculateDistance(LEFT, TOP, BR.x, BR.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - diagAngle;
                        let restrictedAngle = innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle >= 360) {
                            accumulatedRestrictedAngle -= 360;
                        }

                        if (accumulatedRestrictedAngle > 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (BL.y > bottomMargin && !clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'BL_BOTTOM_CCW';
                        }
                        break;
                    }

                    case 'BL_BOTTOM_CCW': {
                        console.log("BL bottom margin rotating counterclockwise");
                        let co = bottomMargin - obj.top;
                        let hypotenuse = calculateDistance(LEFT, TOP, BL.x, BL.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - diagAngle;
                        let restrictedAngle = (2 * Math.PI) - innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle <= -360) {
                            accumulatedRestrictedAngle += 360;
                        }

                        if (accumulatedRestrictedAngle < 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (BR.y > bottomMargin && clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'BR_BOTTOM_CW';
                        }
                        break;
                    }

                    case 'TR_BOTTOM_CW': {
                        console.log("TR bottom margin rotating clockwise");
                        let co = bottomMargin - obj.top;
                        let hypotenuse = calculateDistance(LEFT, TOP, TR.x, TR.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - complementDiagAngle;
                        let restrictedAngle = (Math.PI / 2) + innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle >= 360) {
                            accumulatedRestrictedAngle -= 360;
                        }

                        if (accumulatedRestrictedAngle > 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (BR.y > bottomMargin && !clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'BR_BOTTOM_CCW';
                        }
                        break;
                    }

                    case 'BR_BOTTOM_CCW': {
                        console.log("BR bottom margin rotating counterclockwise");
                        let co = bottomMargin - obj.top;
                        let hypotenuse = calculateDistance(LEFT, TOP, BR.x, BR.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - complementDiagAngle;
                        let restrictedAngle = (Math.PI / 2) - innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle <= -360) {
                            accumulatedRestrictedAngle += 360;
                        }

                        if (accumulatedRestrictedAngle < 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (TR.y > bottomMargin && clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'TR_BOTTOM_CW';
                        }
                        break;
                    }

                    case 'TL_BOTTOM_CW': {
                        console.log("TL bottom margin rotating clockwise");
                        let co = bottomMargin - obj.top;
                        let hypotenuse = calculateDistance(LEFT, TOP, TL.x, TL.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - diagAngle;
                        let restrictedAngle = Math.PI + innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle >= 360) {
                            accumulatedRestrictedAngle -= 360;
                        }

                        if (accumulatedRestrictedAngle > 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (TR.y > bottomMargin && !clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'TR_BOTTOM_CCW';
                        }
                        break;
                    }

                    case 'TR_BOTTOM_CCW': {
                        console.log("TR bottom margin rotating counterclockwise");
                        let co = bottomMargin - obj.top;
                        let hypotenuse = calculateDistance(LEFT, TOP, TR.x, TR.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - diagAngle;
                        let restrictedAngle = Math.PI - innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle <= -360) {
                            accumulatedRestrictedAngle += 360;
                        }

                        if (accumulatedRestrictedAngle < 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (TL.y > bottomMargin && clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'TL_BOTTOM_CW';
                        }
                        break;
                    }

                    case 'BL_BOTTOM_CW': {
                        console.log("BL bottom margin rotating clockwise");
                        let co = bottomMargin - obj.top;
                        let hypotenuse = calculateDistance(LEFT, TOP, BL.x, BL.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - complementDiagAngle;
                        let restrictedAngle = (3 * Math.PI / 2) + innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle >= 360) {
                            accumulatedRestrictedAngle -= 360;
                        }

                        if (accumulatedRestrictedAngle > 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (TL.y > bottomMargin && !clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'TL_BOTTOM_CCW';
                        }
                        break;
                    }

                    case 'TL_BOTTOM_CCW': {
                        console.log("TL bottom margin rotating counterclockwise");
                        let co = bottomMargin - obj.top;
                        let hypotenuse = calculateDistance(LEFT, TOP, TL.x, TL.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - complementDiagAngle;
                        let restrictedAngle = (3 * Math.PI / 2) - innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle <= -360) {
                            accumulatedRestrictedAngle += 360;
                        }

                        if (accumulatedRestrictedAngle < 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (BL.y > bottomMargin && clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'BL_BOTTOM_CW';
                        }
                        break;
                    }

                    case 'TL_LEFT_CCW': {
                        console.log("TL left margin rotating counterclockwise");
                        let co = obj.left - leftMargin;
                        let hypotenuse = calculateDistance(LEFT, TOP, TL.x, TL.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - complementDiagAngle;
                        let restrictedAngle = (2 * Math.PI) - innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle <= -360) {
                            accumulatedRestrictedAngle += 360;
                        }

                        if (accumulatedRestrictedAngle < 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (BL.x < leftMargin && clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'BL_LEFT_CW';
                        }
                        break;
                    }

                    case 'BL_LEFT_CW': {
                        console.log("BL left margin rotating clockwise");
                        let co = obj.left - leftMargin;
                        let hypotenuse = calculateDistance(LEFT, TOP, BL.x, BL.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - complementDiagAngle;
                        let restrictedAngle = innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle >= 360) {
                            accumulatedRestrictedAngle -= 360;
                        }

                        if (accumulatedRestrictedAngle > 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (TL.x < leftMargin && !clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'TL_LEFT_CCW';
                        }
                        break;
                    }

                    case 'BL_LEFT_CCW': {
                        console.log("BL left margin rotating counterclockwise");
                        let co = obj.left - leftMargin;
                        let hypotenuse = calculateDistance(LEFT, TOP, BL.x, BL.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - diagAngle;
                        let restrictedAngle = (Math.PI / 2) - innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle <= -360) {
                            accumulatedRestrictedAngle += 360;
                        }

                        if (accumulatedRestrictedAngle < 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (BR.x < leftMargin && clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'BR_LEFT_CW';
                        }
                        break;
                    }

                    case 'BR_LEFT_CW': {
                        console.log("BR left margin rotating clockwise");
                        let co = obj.left - leftMargin;
                        let hypotenuse = calculateDistance(LEFT, TOP, BR.x, BR.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - diagAngle;
                        let restrictedAngle = (Math.PI / 2) + innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle >= 360) {
                            accumulatedRestrictedAngle -= 360;
                        }

                        if (accumulatedRestrictedAngle > 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (BL.x < leftMargin && !clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'BL_LEFT_CCW';
                        }
                        break;
                    }

                    case 'BR_LEFT_CCW': {
                        console.log("BR left margin rotating counterclockwise");
                        let co = obj.left - leftMargin;
                        let hypotenuse = calculateDistance(LEFT, TOP, BR.x, BR.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - complementDiagAngle;
                        let restrictedAngle = Math.PI - innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle <= -360) {
                            accumulatedRestrictedAngle += 360;
                        }

                        if (accumulatedRestrictedAngle < 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (TR.x < leftMargin && clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'TR_LEFT_CW';
                        }
                        break;
                    }

                    case 'TR_LEFT_CW': {
                        console.log("TR left margin rotating clockwise");
                        let co = obj.left - leftMargin;
                        let hypotenuse = calculateDistance(LEFT, TOP, TR.x, TR.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - complementDiagAngle;
                        let restrictedAngle = Math.PI + innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle >= 360) {
                            accumulatedRestrictedAngle -= 360;
                        }

                        if (accumulatedRestrictedAngle > 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (BR.x < leftMargin && !clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'BR_LEFT_CCW';
                        }
                        break;
                    }

                    case 'TR_LEFT_CCW': {
                        console.log("TR left margin rotating counterclockwise");
                        let co = obj.left - leftMargin;
                        let hypotenuse = calculateDistance(LEFT, TOP, TR.x, TR.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - diagAngle;
                        let restrictedAngle = (3 * Math.PI / 2) - innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle <= -360) {
                            accumulatedRestrictedAngle += 360;
                        }

                        if (accumulatedRestrictedAngle < 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (TL.x < leftMargin && clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'TL_LEFT_CW';
                        }
                        break;
                    }

                    case 'TL_LEFT_CW': {
                        console.log("TL left margin rotating clockwise");
                        let co = obj.left - leftMargin;
                        let hypotenuse = calculateDistance(LEFT, TOP, TL.x, TL.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - diagAngle;
                        let restrictedAngle = (3 * Math.PI / 2) + innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle >= 360) {
                            accumulatedRestrictedAngle -= 360;
                        }

                        if (accumulatedRestrictedAngle > 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (TR.x < leftMargin && !clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'TR_LEFT_CCW';
                        }
                        break;
                    }

                    case 'TL_TOP_CW': {
                        console.log("TL top margin rotating clockwise");
                        let co = obj.top - topMargin;
                        let hypotenuse = calculateDistance(LEFT, TOP, TL.x, TL.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - diagAngle;
                        let restrictedAngle = innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle >= 360) {
                            accumulatedRestrictedAngle -= 360;
                        }

                        if (accumulatedRestrictedAngle > 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (TR.y < topMargin && !clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'TR_TOP_CCW';
                        }
                        break;
                    }

                    case 'TR_TOP_CCW': {
                        console.log("TR top margin rotating counterclockwise");
                        let co = obj.top - topMargin;
                        let hypotenuse = calculateDistance(LEFT, TOP, TR.x, TR.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - diagAngle;
                        let restrictedAngle = (2 * Math.PI) - innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle <= -360) {
                            accumulatedRestrictedAngle += 360;
                        }

                        if (accumulatedRestrictedAngle < 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (TL.y < topMargin && clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'TL_TOP_CW';
                        }
                        break;
                    }

                    case 'BL_TOP_CW': {
                        console.log("BL top margin rotating clockwise");
                        let co = obj.top - topMargin;
                        let hypotenuse = calculateDistance(LEFT, TOP, BL.x, BL.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - complementDiagAngle;
                        let restrictedAngle = (Math.PI / 2) + innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle >= 360) {
                            accumulatedRestrictedAngle -= 360;
                        }

                        if (accumulatedRestrictedAngle > 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (TL.y < topMargin && !clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'TL_TOP_CCW';
                        }
                        break;
                    }

                    case 'TL_TOP_CCW': {
                        console.log("TL top margin rotating counterclockwise");
                        let co = obj.top - topMargin;
                        let hypotenuse = calculateDistance(LEFT, TOP, TL.x, TL.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - complementDiagAngle;
                        let restrictedAngle = (Math.PI / 2) - innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle <= -360) {
                            accumulatedRestrictedAngle += 360;
                        }

                        if (accumulatedRestrictedAngle < 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (BL.y < topMargin && clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'BL_TOP_CW';
                        }
                        break;
                    }

                    case 'BR_TOP_CW': {
                        console.log("BR top margin rotating clockwise");
                        let co = obj.top - topMargin;
                        let hypotenuse = calculateDistance(LEFT, TOP, BR.x, BR.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - diagAngle;
                        let restrictedAngle = Math.PI + innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle >= 360) {
                            accumulatedRestrictedAngle -= 360;
                        }

                        if (accumulatedRestrictedAngle > 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (BL.y < topMargin && !clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'BL_TOP_CCW';
                        }
                        break;
                    }

                    case 'BL_TOP_CCW': {
                        console.log("BL top margin rotating counterclockwise");
                        let co = obj.top - topMargin;
                        let hypotenuse = calculateDistance(LEFT, TOP, BL.x, BL.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - diagAngle;
                        let restrictedAngle = Math.PI - innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle <= -360) {
                            accumulatedRestrictedAngle += 360;
                        }

                        if (accumulatedRestrictedAngle < 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (BR.y < topMargin && clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'BR_TOP_CW';
                        }
                        break;
                    }

                    case 'TR_TOP_CW': {
                        console.log("TR top margin rotating clockwise");
                        let co = obj.top - topMargin;
                        let hypotenuse = calculateDistance(LEFT, TOP, TR.x, TR.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - complementDiagAngle;
                        let restrictedAngle = (3 * Math.PI / 2) + innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle >= 360) {
                            accumulatedRestrictedAngle -= 360;
                        }

                        if (accumulatedRestrictedAngle > 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (BR.y < topMargin && !clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'BR_TOP_CCW';
                        }
                        break;
                    }

                    case 'BR_TOP_CCW': {
                        console.log("BR top margin rotating counterclockwise");
                        let co = obj.top - topMargin;
                        let hypotenuse = calculateDistance(LEFT, TOP, BR.x, BR.y);
                        let marginAngle = Math.asin(co / hypotenuse);
                        let innerAngle = marginAngle - complementDiagAngle;
                        let restrictedAngle = (3 * Math.PI / 2) - innerAngle;

                        accumulatedRestrictedAngle += angleDiff;

                        // Update full rotations
                        while (accumulatedRestrictedAngle <= -360) {
                            accumulatedRestrictedAngle += 360;
                        }

                        if (accumulatedRestrictedAngle < 0) {
                            obj.angle = radToDeg(restrictedAngle);
                        } else if (TR.y < topMargin && clockwise) {
                            accumulatedRestrictedAngle = 0;
                            activeRestriction = 'TR_TOP_CW';
                        }
                        break;
                    }

                    default:
                        // Handle default case
                        break;

                }

            }

            checkRotating();

            obj.setCoords();
            canvas.renderAll();
        });

        canvas.on('object:modified', function (e) {
            // Reset restrictions
            activeRestriction = null;
        });

        // Detectar inicio de la manipulación de un objeto
        canvas.on('before:transform', function () {
            let obj = canvas.getActiveObject();
            //console.log('Antes de transformar el objeto:', obj);
        });


        // Add this variable outside the event handler
        let activeRestriction = null;

        canvas.on('object:scaling', function (e) {
            let obj = e.target;
            obj.setCoords();

            let realObjectWidth = obj.width * obj.scaleX;
            let realObjectHeight = obj.height * obj.scaleY;

            const marginRight = marginRect.left + marginRect.width;
            const marginBottom = marginRect.top + marginRect.height;

            const TL = obj.aCoords.tl;
            const TR = obj.aCoords.tr;
            const BL = obj.aCoords.bl;
            const BR = obj.aCoords.br;

            // Check if any of the object's corners are outside the margin
            if (TL.x < marginRect.left || TR.x > marginRight || BL.x < marginRect.left || BR.x > marginRight ||
                TL.y < marginRect.top || TR.y < marginRect.top || BL.y > marginBottom || BR.y > marginBottom) {

                // Revert to last valid scale and center coordinates
                obj.scaleX = obj._lastScaleX;
                obj.scaleY = obj._lastScaleY;
                obj.left = obj._lastLeft;
                obj.top = obj._lastTop;
                obj.setCoords();
            } else {
                // Save the current valid scale and center coordinates
                obj._lastScaleX = obj.scaleX;
                obj._lastScaleY = obj.scaleY;
                obj._lastLeft = obj.left;
                obj._lastTop = obj.top;
            }

            obj.setCoords();
            canvas.renderAll();
        });

        resizeCanvas('carta');

        // Calcular el ancho del margen

        let marginWidth = (canvas.width - marginRect.width) / 2;

    </script>
</body>

</html>