<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asistente de impresión de Imágenes</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 1.25rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .main-container {
            display: flex;
            gap: 1.25rem;
            align-items: flex-start;
        }

        #canvas-container {
            border: 1px solid black;
        }

        .button-container {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }

        .size-button,
        .control-button,
        .orientation-button {
            padding: 0.938rem 1.875rem;
            font-size: 1.125rem;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 0.313rem;
            transition: background-color 0.3s;
            width: 12.5rem;
        }

        .size-button:hover,
        .control-button:hover,
        .orientation-button:hover {
            background-color: #45a049;
        }

        .size-button:active,
        .control-button:active,
        .orientation-button:active {
            background-color: #3e8e41;
        }

        #imageLoader {
            display: none;
        }

        .control-button[for="imageLoader"] {
            display: inline-block;
            text-align: center;
            width: 8.75rem;
        }

        .control-group input[type="checkbox"] {
            margin-right: 0.5rem;
            width: 1.25rem;
            height: 1.25rem;
            cursor: pointer;
        }

        .control-group input[type="checkbox"]:checked {
            background-color: #3e8e41;
            border-color: #3e8e41;
        }

        .control-group label {
            font-family: Arial, sans-serif;
            color: #333;
            cursor: pointer;
        }

        .zoom-controls {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            display: flex;
            gap: 1rem;
            z-index: 1000;
        }

        .zoom-btn {
            padding: 1.25rem 1.875rem;
            font-size: 1.5rem;
            width: 4rem;
            height: 4rem;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .zoom-btn i {
            font-size: 2rem;
        }

        .zoom-btn:hover {
            background-color: #45a049;
        }

        #main-content {
            transform-origin: center top;
            transition: transform 0.3s ease;
        }

        #confirmCrop {
            display: none;
            background-color: #4CAF50;
        }

        #cancelCrop {
            display: none;
            background-color: #f44336;
        }

        hr {
            border: none;
            border-top: 2px dashed darkgray;
            margin: 1.25rem 0;
            width: 12.5rem;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
</head>

<body>
    <div id="main-content">
        <div class="main-container">
            <div class="button-container">
                <label for="imageLoader" class="control-button">Cargar imágenes</label>
                <input type="file" id="imageLoader" accept="image/*" multiple aria-label="Cargar imágenes">
                <button type="button" id="printButton" class="control-button">Imprimir</button>
                <button type="button" id="deleteButton" class="control-button">Eliminar imagen</button>
                <button type="button" id="resetImageButton" class="control-button">Restablecer imagen</button>
                <button type="button" id="arrangeBtn" class="control-button">Ordenar imágenes</button>
                <button type="button" id="grayScaleBtn" class="control-button">Convertir a blanco y negro</button>
                <hr>
                <button type="button" id="cropButton" class="control-button">Recortar imagen</button>
                <button type="button" id="confirmCrop" class="control-button">✓ Confirmar</button>
                <button type="button" id="cancelCrop" class="control-button">✗ Cancelar</button>
                <div class="control-group">
                    <input type="checkbox" id="rotateControl">
                    <label for="rotateControl">Permitir rotación libre</label>
                </div>
            </div>
            <div id="canvas-container">
                <canvas id="canvas"></canvas>
            </div>
            <div class="button-container">
                <button type="button" class="size-button" id="cartaButton">CARTA</button>
                <button type="button" class="size-button" id="oficioButton">OFICIO</button>
                <button type="button" class="orientation-button" id="verticalButton">▯ Vertical</button>
                <button type="button" class="orientation-button" id="horizontalButton">▭ Horizontal</button>
                <button type="button" id="rotateButton+90" class="control-button">Girar 90 grados a la derecha
                    ↻</button>
                <button type="button" id="rotateButton-90" class="control-button">Girar 90 grados a la izquierda
                    ↺</button>
            </div>
        </div>
    </div>

    <div class="zoom-controls">
        <button type="button" class="zoom-btn" onclick="zoomIn()" title="Aumentar zoom">
            <i class="fas fa-search-plus"></i>
        </button>
        <button type="button" class="zoom-btn" onclick="zoomOut()" title="Reducir zoom">
            <i class="fas fa-search-minus"></i>
        </button>
    </div>

    <script>
        let currentZoom = 1;
        const zoomFactor = 0.1;
        const maxZoom = 2;
        const minZoom = 0.5;

        function zoomIn() {
            if (currentZoom < maxZoom) {
                currentZoom += zoomFactor;
                applyZoom();
            }
        }

        function zoomOut() {
            if (currentZoom > minZoom) {
                currentZoom -= zoomFactor;
                applyZoom();
            }
        }

        function applyZoom() {
            document.getElementById('main-content').style.transform = `scale(${currentZoom})`;
        }

        const canvasElement = document.getElementById('canvas');
        let canvas = new fabric.Canvas('canvas');
        const imageLoader = document.getElementById('imageLoader');
        const deleteButton = document.getElementById('deleteButton');
        const printButton = document.getElementById('printButton');
        const cartaButton = document.getElementById('cartaButton');
        const oficioButton = document.getElementById('oficioButton');
        const verticalButton = document.getElementById('verticalButton');
        const horizontalButton = document.getElementById('horizontalButton');
        const rotateButton_p90 = document.getElementById('rotateButton+90');
        const rotateButton_n90 = document.getElementById('rotateButton-90');
        const resetImageButton = document.getElementById('resetImageButton');
        const arrangeBtn = document.getElementById('arrangeBtn');
        const cropButton = document.getElementById('cropButton');
        const confirmCropBtn = document.getElementById('confirmCrop');
        const cancelCropBtn = document.getElementById('cancelCrop');
        const rotateCheckbox = document.getElementById('rotateControl');
        const grayScaleBtn = document.getElementById('grayScaleBtn');

        const dpi = 300;
        const marginInches = 0.2;
        const marginPixels = marginInches * dpi;
        const paperSizes = {
            carta: { width: 8.5 * dpi, height: 11 * dpi },
            oficio: { width: 8.5 * dpi, height: 13 * dpi }
        };

        let currentSize = 'carta';
        let isVertical = true;
        let marginRect;

        let cropRect = null;
        let activeImage = null;
        let isCropping = false;
        let inactivatedObjects = [];

        function disableOtherObjects() {
            canvas.getObjects().forEach(obj => {
                if (obj !== cropRect && obj !== marginRect) {
                    inactivatedObjects.push({
                        object: obj,
                        originalOpacity: obj.opacity
                    });

                    if (obj !== activeImage) {
                        obj.set({
                            opacity: 0.3,
                        });
                    }
                    obj.set({
                        selectable: false,
                        evented: false
                    });
                }
            });
            canvas.requestRenderAll();
        }

        // Modify the restore function
        function restoreOtherObjects() {
            inactivatedObjects.forEach(item => {
                // Don't restore properties for background
                if (item.object.name !== 'background') {
                    item.object.set({
                        opacity: item.originalOpacity,
                        selectable: true,
                        evented: true
                    });
                }
            });
            inactivatedObjects = [];
            canvas.requestRenderAll();
        }

        function enterCropMode(imgObject) {
            activeImage = imgObject;
            isCropping = true;

            // Get image bounding rect
            const bounds = imgObject.getBoundingRect();

            // Create crop rect using bounds
            cropRect = new fabric.Rect({
                left: bounds.left,
                top: bounds.top,
                width: bounds.width,
                height: bounds.height,
                fill: 'transparent',
                stroke: '#000',
                strokeWidth: 1,
                strokeDashArray: [5, 5],
                absolutePositioned: true,
                transparentCorners: false,
                cornerColor: 'DodgerBlue',
                cornerStyle: 'circle',
                cornerSize: 12,
                cornerStrokeColor: 'Blue'
            });

            canvas.add(cropRect);

            // Bring both objects to front
            imgObject.bringToFront();
            cropRect.bringToFront();

            // Disable other objects
            disableOtherObjects();

            canvas.setActiveObject(cropRect);

            // Show crop control buttons
            confirmCropBtn.style.display = 'inline';
            cancelCropBtn.style.display = 'inline';
            cropButton.style.display = 'none';
        }

        // Add this global variable at the top of your script
        let canvasBackground = null;

        // Modify the background creation function
        function createCanvasBackground() {
            // Remove existing background if it exists
            if (canvasBackground) {
                canvas.remove(canvasBackground);
            }

            canvasBackground = new fabric.Rect({
                left: 0,
                top: 0,
                width: canvas.width,
                height: canvas.height,
                fill: 'white',
                selectable: false,
                evented: false,
                name: 'background' // Add an identifier
            });

            canvas.add(canvasBackground);
            canvas.sendToBack(canvasBackground);
        }

        function confirmCrop() {
            if (!isCropping || !cropRect || !activeImage) return;

            // Get the cropping rect and original image's ID
            const rect = cropRect;
            const img = activeImage;
            const originalId = img.id; // Save original ID

            // Set the crop rect stroke to transparent so that it doesn't bleed into the final image
            rect.set('stroke', 'transparent');

            // Create a background to fill the canvas with white color
            createCanvasBackground();

            // Hide other objects
            canvas.getObjects().forEach(obj => {
                if (obj !== cropRect && obj !== marginRect && obj !== activeImage && obj !== canvasBackground) {
                    obj.set({
                        opacity: 0,
                    });
                }
            });

            // Create new cropped image
            const cropped = new Image();
            cropped.src = canvas.toDataURL({
                left: rect.left,
                top: rect.top,
                width: rect.width * rect.scaleX,
                height: rect.height * rect.scaleY
            });

            cropped.onload = function () {
                // Remove old image and crop rect
                canvas.remove(img);
                canvas.remove(rect);

                // Create and add new cropped image
                const newImage = new fabric.Image(cropped);
                newImage.set({
                    id: originalId, // Transfer the original ID
                    left: rect.left,
                    top: rect.top,
                });

                // Set rotation control visibility based on checkbox state
                newImage.setControlsVisibility({
                    mtr: rotateCheckbox.checked
                });

                newImage.setCoords();
                canvas.add(newImage);
                canvas.renderAll();
            };

            exitCropMode();
        }

        function exitCropMode() {
            if (cropRect) {
                canvas.remove(cropRect);
                cropRect = null;
            }

            isCropping = false;
            activeImage = null;

            // Restore other objects
            restoreOtherObjects();

            // Hide crop control buttons
            confirmCropBtn.style.display = 'none';
            cancelCropBtn.style.display = 'none';
            cropButton.style.display = 'inline';
        }

        function deactivateObjects(event) {
            const canvasElement = canvas.getElement();
            const isOnCanvasElement = event.target === canvasElement;
            const isOnFabricControls = event.target.classList.contains('canvas-container') ||
                event.target.classList.contains('upper-canvas') ||
                event.target.classList.contains('lower-canvas');
            const isOnButton = event.target.tagName === 'BUTTON' ||
                event.target.closest('button') !== null;

            const isOnCheckbox = event.target.tagName === 'INPUT' &&
                event.target.type === 'checkbox';

            const isOnCheckBoxLabel = event.target.tagName === 'LABEL' &&
                event.target.htmlFor === 'rotateControl';

            if (!isOnCanvasElement && !isOnFabricControls && !isOnButton && !isOnCheckbox && !isOnCheckBoxLabel) {
                canvas.discardActiveObject();
                canvas.requestRenderAll();
            }
        }

        function degToRad(degrees) {
            return degrees * (Math.PI / 180);
        }

        function radToDeg(radians) {
            return radians * (180 / Math.PI);
        }

        function resizeCanvas(size, orientation = isVertical) {
            currentSize = size;
            isVertical = orientation;
            const scale = 0.3;
            let width = paperSizes[size].width;
            let height = paperSizes[size].height;

            if (!isVertical) {
                [width, height] = [height, width];
            }

            canvas.setWidth(width * scale);
            canvas.setHeight(height * scale);

            if (marginRect) {
                canvas.remove(marginRect);
            }

            marginRect = new fabric.Rect({
                width: width * scale - (2 * marginPixels * scale),
                height: height * scale - (2 * marginPixels * scale),
                left: marginPixels * scale,
                top: marginPixels * scale,
                fill: 'transparent',
                stroke: 'gray',
                strokeWidth: 1,
                strokeDashArray: [5, 5],
                selectable: false,
                evented: false
            });

            canvas.add(marginRect);
            canvas.renderAll();

            // Actualizar los límites para todas las imágenes existentes
            canvas.forEachObject(function (obj) {
                if (obj !== marginRect) {
                    obj.setCoords();
                }
            });
        }

        function changeOrientation(vertical) {
            resizeCanvas(currentSize, vertical);
        }

        // Add this at the top with other variables
        const originalImages = {};

        function handleImageUpload(e) {
            const files = e.target.files;
            const loadedImages = [];

            for (const element of files) {
                const file = element;
                const reader = new FileReader();
                reader.onload = function (event) {
                    fabric.Image.fromURL(event.target.result, function (img) {
                        const imageId = `image-${Date.now()}`;
                        img.id = imageId;
                        img.originalUrl = event.target.result; // Store URL for later use

                        // Set rotation control visibility based on checkbox state
                        img.setControlsVisibility({
                            mtr: rotateCheckbox.checked
                        });

                        loadedImages.push(img);

                        if (loadedImages.length === files.length) {
                            // Choose arrangement function based on number of images
                            if (files.length <= 2) {
                                arrangeImagesCols(loadedImages);
                                lastArrangement = 'cols';
                            } else {
                                arrangeImagesRows(loadedImages);
                                lastArrangement = 'rows';
                            }
                        }
                    });
                }
                reader.readAsDataURL(file);
            }
        }

        // Función para redondear a un número específico de decimales
        function roundToDecimals(value, decimals) {
            return Number(value.toFixed(decimals));
        }

        function arrangeImagesRows(images) {

            const count = images.length;
            let marginAdjustment;
            if (count === 1) {
                marginAdjustment = 100;
            } else if (count === 2) {
                marginAdjustment = 50;
            } else {
                marginAdjustment = 20;
            }
            const margin = marginWidth + marginAdjustment;

            const cols = Math.ceil(Math.sqrt(count));
            const rows = Math.ceil(count / cols);

            const cellWidth = (canvas.width - margin * 2) / cols;
            const cellHeight = (canvas.height - margin * 2) / rows;

            // Add index to make IDs unique
            images.forEach((img, index) => {
                img.id = `image-${Date.now()}-${index}`;
                const row = Math.floor(index / cols);
                const col = index % cols;

                let realImagetWidth = img.width * img.scaleX;
                let realImageHeight = img.height * img.scaleY;

                let bounds = img.getBoundingRect();

                // Redondear antes de calcular el offset
                let roundedBoundsWidth = roundToDecimals(bounds.width, 2);

                let roundedImageWidth = roundToDecimals(realImagetWidth, 2);

                const offsetWidthImageBound = roundToDecimals(roundedBoundsWidth - roundedImageWidth, 2);

                let roundedBoundsHeight = roundToDecimals(bounds.height, 2);

                let roundedImageHeight = roundToDecimals(realImageHeight, 2);

                const offsetHeightImageBound = roundToDecimals(roundedBoundsHeight - roundedImageHeight, 2);

                const scaleFactor = Math.min(
                    (cellWidth - margin - offsetWidthImageBound) / img.width,
                    (cellHeight - margin - offsetHeightImageBound) / img.height
                );

                img.scale(scaleFactor);

                img.set({
                    left: margin + col * cellWidth + cellWidth / 2,
                    top: margin + row * cellHeight + cellHeight / 2,
                    originX: 'center',
                    originY: 'center'
                });

                // Store final state with top/left origin
                originalImages[img.id] = {
                    url: img.originalUrl,
                    width: img.width,
                    height: img.height,
                    scaleX: img.scaleX,
                    scaleY: img.scaleY,
                    angle: img.angle,
                    left: img.left,
                    top: img.top
                };

                canvas.add(img);
            });

            canvas.renderAll();

        }

        function arrangeImagesCols(images) {

            const count = images.length;
            let marginAdjustment;
            if (count === 1) {
                marginAdjustment = 100;
            } else if (count === 2) {
                marginAdjustment = 50;
            } else {
                marginAdjustment = 20;
            }
            const margin = marginWidth + marginAdjustment;

            const rows = Math.ceil(Math.sqrt(count));
            const cols = Math.ceil(count / rows);

            const cellWidth = (canvas.width - margin * 2) / cols;
            const cellHeight = (canvas.height - margin * 2) / rows;

            // Add index to make IDs unique
            images.forEach((img, index) => {
                img.id = `image-${Date.now()}-${index}`;
                const col = Math.floor(index / rows);
                const row = index % rows;

                let realImagetWidth = img.width * img.scaleX;
                let realImageHeight = img.height * img.scaleY;

                let bounds = img.getBoundingRect();

                // Redondear antes de calcular el offset
                let roundedBoundsWidth = roundToDecimals(bounds.width, 2);

                let roundedImageWidth = roundToDecimals(realImagetWidth, 2);

                const offsetWidthImageBound = roundToDecimals(roundedBoundsWidth - roundedImageWidth, 2);

                let roundedBoundsHeight = roundToDecimals(bounds.height, 2);

                let roundedImageHeight = roundToDecimals(realImageHeight, 2);

                const offsetHeightImageBound = roundToDecimals(roundedBoundsHeight - roundedImageHeight, 2);

                const scaleFactor = Math.min(
                    (cellWidth - margin - offsetWidthImageBound) / img.width,
                    (cellHeight - margin - offsetHeightImageBound) / img.height
                );

                img.scale(scaleFactor);

                img.set({
                    left: margin + col * cellWidth + cellWidth / 2,
                    top: margin + row * cellHeight + cellHeight / 2,
                    originX: 'center',
                    originY: 'center'
                });

                // Store final state with top/left origin
                originalImages[img.id] = {
                    url: img.originalUrl,
                    width: img.width,
                    height: img.height,
                    scaleX: img.scaleX,
                    scaleY: img.scaleY,
                    angle: img.angle,
                    left: img.left,
                    top: img.top
                };

                canvas.add(img);
            });

            canvas.renderAll();
        }

        // Reset active image to its original state
        function resetActiveImage() {
            const activeObject = canvas.getActiveObject();
            if (!activeObject || !activeObject.id || !originalImages[activeObject.id]) {
                alert('Por favor seleccione una imagen para restablecer');
                return;
            }

            const original = originalImages[activeObject.id];

            fabric.Image.fromURL(original.url, function (img) {
                // Apply original properties to new image
                img.set({
                    id: activeObject.id,
                    scaleX: original.scaleX,
                    scaleY: original.scaleY,
                    angle: original.angle,
                    left: original.left,
                    top: original.top,
                    originX: 'center',
                    originY: 'center'
                });

                // Replace old image with new one
                canvas.remove(activeObject);
                canvas.add(img);
                canvas.setActiveObject(img);
                canvas.renderAll();
            });
        }

        function printCanvas() {

            // Store original opacity
            const originalOpacity = marginRect.opacity;

            // Make margin invisible for printing
            marginRect.opacity = 0;
            canvas.renderAll();

            const dataUrl = canvas.toDataURL({
                format: 'png',
                quality: 1,
                multiplier: 1 / canvas.getZoom()
            });

            const windowContent = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Imprimir Canvas</title>
                    <meta name="viewport" content="width=device-width, initial-scale=1">
                    <style>
                        @page {
                            margin: 0;
                            size: auto;
                        }
                        body {
                            margin: 0;
                            padding: 0;
                        }
                        img {
                            width: 100%;
                            height: auto;
                            display: block;
                            margin: 0;
                        }
                    </style>
                </head>
                <body>
                    <img src="${dataUrl}">
                </body>
                </html>`;

            const printWin = window.open('', '', 'width=800,height=600');
            printWin.document.open();
            printWin.document.write(windowContent);
            printWin.document.close();
            printWin.setTimeout(function () {
                printWin.focus();
                printWin.print();
                printWin.close();
                marginRect.opacity = originalOpacity;
                canvas.renderAll();
            }, 250);
        }

        function rotateImage(deg) {
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                activeObject.rotate((activeObject.angle + deg) % 360);
                activeObject.setCoords();

                canvas.renderAll();
            }
        }

        function deleteActiveObject() {
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                canvas.remove(activeObject);
                canvas.renderAll();
            }
        }

        function convertToGrayscale() {
            const activeObject = canvas.getActiveObject();
            if (!activeObject) {
                alert('Please select an image first');
                return;
            }

            // Apply grayscale filter
            activeObject.filters.push(new fabric.Image.filters.Grayscale());

            // Apply the filters and re-render
            activeObject.applyFilters();
            canvas.renderAll();
        }

        cartaButton.addEventListener('click', () => resizeCanvas('carta'));
        oficioButton.addEventListener('click', () => resizeCanvas('oficio'));
        verticalButton.addEventListener('click', () => changeOrientation(true));
        horizontalButton.addEventListener('click', () => changeOrientation(false));

        imageLoader.addEventListener('change', handleImageUpload);
        resetImageButton.addEventListener('click', resetActiveImage);
        printButton.addEventListener('click', printCanvas);
        grayScaleBtn.addEventListener('click', convertToGrayscale);
        rotateButton_p90.addEventListener('click', () => rotateImage(90));
        rotateButton_n90.addEventListener('click', () => rotateImage(270));

        let lastArrangement = 'rows'; // Track the last arrangement type

        arrangeBtn.addEventListener('click', function () {
            // 1. Obtener todas las imágenes actuales
            const images = canvas.getObjects().filter(obj => obj.type === 'image');

            // 2. Remover todas las imágenes existentes del canvas
            images.forEach(img => canvas.remove(img));

            if (lastArrangement === 'rows') {
                arrangeImagesCols(images);
                lastArrangement = 'cols';
            } else {
                arrangeImagesRows(images);
                lastArrangement = 'rows';
            }

            canvas.renderAll();
        });

        rotateCheckbox.addEventListener('change', function (e) {
            canvas.getObjects().forEach(obj => {
                if (obj.type === 'image') {
                    obj.setControlsVisibility({
                        mtr: this.checked
                    });
                }
            });
            canvas.requestRenderAll();
        });

        deleteButton.addEventListener('click', deleteActiveObject);

        // Add keyboard delete support
        document.addEventListener('keydown', function (event) {
            if (event.key === 'Delete') {
                deleteActiveObject();
            }
        });

        cropButton.addEventListener('click', function () {
            const activeObject = canvas.getActiveObject();
            if (!activeObject || activeObject.type !== 'image') return;

            enterCropMode(activeObject);
        });

        confirmCropBtn.addEventListener('click', confirmCrop);

        cancelCropBtn.addEventListener('click', exitCropMode);

        document.body.addEventListener('click', () => deactivateObjects(event));

        fabric.Object.prototype.transparentCorners = false;
        fabric.Object.prototype.cornerColor = 'limegreen';
        fabric.Object.prototype.cornerStrokeColor = 'black';
        fabric.Object.prototype.cornerStyle = 'rect';
        fabric.Object.prototype.cornerSize = 12;
        const controls = fabric.Object.prototype.controls;
        const rotateControls = controls.mtr;
        rotateControls.visible = false;

        canvas.on('object:moving', function (e) {
            let obj = e.target;
            obj.setCoords(); // Actualiza las coordenadas del objeto

            // Obtener los puntos del objeto y del margen
            let objPoints = [obj.aCoords.tl, obj.aCoords.tr, obj.aCoords.br, obj.aCoords.bl];

            let marginRight = (marginRect.left + marginRect.width);
            let marginBottom = (marginRect.top + marginRect.height);

            // Inicializar desplazamientos
            let offsetX = 0, offsetY = 0;

            // Comprobar cada punto del objeto
            objPoints.forEach(function (point) {
                if (point.x < marginRect.left) {
                    offsetX = Math.max(offsetX, marginRect.left - point.x);
                }
                if (point.x > marginRight) {
                    offsetX = Math.min(offsetX, marginRight - point.x);
                }
                if (point.y < marginRect.top) {
                    offsetY = Math.max(offsetY, marginRect.top - point.y);
                }
                if (point.y > marginBottom) {
                    offsetY = Math.min(offsetY, marginBottom - point.y);
                }
            });

            // Aplicar desplazamientos si es necesario
            if (offsetX !== 0 || offsetY !== 0) {
                obj.left += offsetX;
                obj.top += offsetY;
                obj.setCoords(); // Actualiza las coordenadas después de ajustar la posición
            }
        });

        function findMidpointFromPoints(point1, point2) {
            return {
                x: (point1.x + point2.x) / 2,
                y: (point1.y + point2.y) / 2
            };
        }

        function drawCircle(x1, x2, color) {
            // Add red circle at 
            const circle = new fabric.Circle({
                left: x1,
                top: x2,
                originX: 'center',
                originY: 'center',
                radius: 5,
                fill: color || 'red',
                selectable: false
            });
            canvas.add(circle);

        }

        function drawRectangle(x, y, width, height, options = {}) {
            // Default options merged with provided options
            const defaultOptions = {
                left: x,
                top: y,
                width: width,
                height: height,
                fill: 'transparent',
                stroke: 'black',
                strokeWidth: 2,
                selectable: true
            };

            const finalOptions = { ...defaultOptions, ...options };

            // Create new rectangle
            const rectangle = new fabric.Rect(finalOptions);

            // Add to canvas
            canvas.add(rectangle);
            canvas.renderAll();

            return rectangle;
        }

        function drawLine(coords, options = {}) {
            // Default options merged with provided options
            const defaultOptions = {
                fill: 'black',
                stroke: 'black',
                strokeWidth: 2,
                selectable: false
            };

            const finalOptions = { ...defaultOptions, ...options };

            // Create new line
            const line = new fabric.Line(coords, finalOptions);

            // Add to canvas
            canvas.add(line);
            canvas.renderAll();

            return line;
        }

        // Reset activeRestriction when scaling ends
        canvas.on('object:modified', function (e) {
            activeRestriction = null;
        });

        // Add this variable outside the event handler
        let activeRestriction = null;

        canvas.on('object:scaling', function (e) {
            let obj = e.target;
            obj.setCoords();

            let realObjectWidth = obj.width * obj.scaleX;
            let realObjectHeight = obj.height * obj.scaleY;

            // Comparar valores previos y actuales de scaleX y scaleY
            const scaleXChanged = obj.scaleX !== obj._lastScaleX;
            const scaleYChanged = obj.scaleY !== obj._lastScaleY;

            // Verificamos si el objeto excede los márgenes

            let marginRight = (marginRect.left + marginRect.width);
            let marginBottom = (marginRect.top + marginRect.height);

            let TL = obj.aCoords.tl;
            let TR = obj.aCoords.tr;
            let BL = obj.aCoords.bl;
            let BR = obj.aCoords.br;

            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

            let MB = obj.oCoords.mb;
            let MT = obj.oCoords.mt;
            let ML = obj.oCoords.ml;
            let MR = obj.oCoords.mr;

            // Para establecer la posición y el escalado de objeto hay que darle las propiedades left, top, scaleX y scaleY

            function checkPosition(point) {

                // Check if object is still violating margins
                if (activeRestriction === 'TL_RIGHT' && TL.x <= marginRight) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'TR_RIGHT' && TR.x <= marginRight) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'BR_RIGHT' && BR.x <= marginRight) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'BL_RIGHT' && BL.x <= marginRight) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'TL_BOTTOM' && TL.y <= marginBottom) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'TR_BOTTOM' && TR.y <= marginBottom) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'BR_BOTTOM' && BR.y <= marginBottom) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'BL_BOTTOM' && BL.y <= marginBottom) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'TL_LEFT' && TL.x >= marginRect.left) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'TR_LEFT' && TR.x >= marginRect.left) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'BR_LEFT' && BR.x >= marginRect.left) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'BL_LEFT' && BL.x >= marginRect.left) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'TL_TOP' && TL.y >= marginRect.top) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'TR_TOP' && TR.y >= marginRect.top) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'BR_TOP' && BR.y >= marginRect.top) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'BL_TOP' && BL.y >= marginRect.top) {
                    activeRestriction = null;
                }


                // Check positions and set activeRestriction if not set
                if (!activeRestriction) {
                    if (TL.x > marginRight && obj.angle > 90 && obj.angle <= 180) {
                        activeRestriction = 'TL_RIGHT';
                    } else if (TR.x > marginRight && obj.angle >= 0 && obj.angle <= 90) {
                        activeRestriction = 'TR_RIGHT';
                    } else if (BR.x > marginRight && obj.angle >= 270 && obj.angle < 360) {
                        activeRestriction = 'BR_RIGHT';
                    } else if (BL.x > marginRight && obj.angle >= 180 && obj.angle < 270) {
                        activeRestriction = 'BL_RIGHT';
                    } else if (TL.y > marginBottom && obj.angle >= 180 && obj.angle < 270) {
                        activeRestriction = 'TL_BOTTOM';
                    } else if (TR.y > marginBottom && obj.angle > 90 && obj.angle <= 180) {
                        activeRestriction = 'TR_BOTTOM';
                    } else if (BR.y > marginBottom && obj.angle >= 0 && obj.angle <= 90) {
                        activeRestriction = 'BR_BOTTOM';
                    } else if (BL.y > marginBottom && obj.angle >= 270 && obj.angle < 360) {
                        activeRestriction = 'BL_BOTTOM';
                    } else if (TL.x < marginRect.left && obj.angle >= 270 && obj.angle < 360) {
                        activeRestriction = 'TL_LEFT';
                    } else if (TR.x < marginRect.left && obj.angle >= 180 && obj.angle < 270) {
                        activeRestriction = 'TR_LEFT';
                    } else if (BR.x < marginRect.left && obj.angle >= 90 && obj.angle < 180) {
                        activeRestriction = 'BR_LEFT';
                    } else if (BL.x < marginRect.left && obj.angle >= 0 && obj.angle < 90) {
                        activeRestriction = 'BL_LEFT';
                    } else if (TL.y < marginRect.top && obj.angle >= 0 && obj.angle < 90) {
                        activeRestriction = 'TL_TOP';
                    } else if (TR.y < marginRect.top && obj.angle >= 270 && obj.angle < 360) {
                        activeRestriction = 'TR_TOP';
                    } else if (BR.y < marginRect.top && obj.angle >= 180 && obj.angle < 270) {
                        activeRestriction = 'BR_TOP';
                    } else if (BL.y < marginRect.top && obj.angle >= 90 && obj.angle < 180) {
                        activeRestriction = 'BL_TOP';
                    }
                }

                switch (activeRestriction) {
                    case 'TL_RIGHT':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Top Left supera el margen derecho escalando horizontal y verticalmente");

                            let offsetAngle = diagAngle - degToRad(180 - obj.angle);

                            let xOffset = TL.x - marginRight;

                            let yOffset = xOffset * Math.tan(offsetAngle);

                            let yCollision = TL.y - yOffset;

                            let collisionToAnchorWidth = marginRight - BR.x;

                            let collisionToAnchorHeight = yCollision - BR.y;

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = BR.x + collisionToAnchorWidth / 2;

                            obj.top = BR.y + collisionToAnchorHeight / 2;

                        } else if (scaleXChanged) {

                            console.log("La esquina Top Left supera el margen derecho escalando horizontalmente");

                            let rectAngle = obj.angle - 90;

                            let co = marginRight - TR.x;

                            let restrictedObjWidth = co / Math.sin(degToRad(rectAngle));

                            let ca = restrictedObjWidth * Math.cos(degToRad(rectAngle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = MR.x + co / 2;

                            obj.top = MR.y - ca / 2;

                        } else if (scaleYChanged) {

                            console.log("La esquina Top Left supera el margen derecho escalando verticalmente");

                            let rectAngle = obj.angle - 90;

                            let ca = marginRight - BL.x;

                            let restrictedObjectHeight = ca / Math.cos(degToRad(rectAngle));

                            let co = restrictedObjectHeight * Math.sin(degToRad(rectAngle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = MB.x + ca / 2;

                            obj.top = MB.y + co / 2;

                        }

                        break;

                    case 'TR_RIGHT':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Top Right supera el margen derecho escalando horizontal y verticalmente");

                            // hallar angulo de la diagonal desde la base a la diagonal del rectangulo

                            let offsetAngle = diagAngle - degToRad(obj.angle);

                            let xOffset = TR.x - marginRight;

                            let yOffset = xOffset * Math.tan(offsetAngle);

                            let yCollision = Math.abs(TR.y + yOffset);

                            // Calcular las escalas x y y restringidas

                            // Calcular la distancia de la diagonal del rectangulo restringido

                            let collisionToAnchorWidth = Math.abs(marginRight - BL.x);

                            let collisionToAnchorHeight = yCollision - BL.y;

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = BL.x + collisionToAnchorWidth / 2;

                            obj.top = BL.y + collisionToAnchorHeight / 2;

                        } else if (scaleXChanged) {

                            console.log("La esquina Top Right supera el margen derecho escalando horizontalmente");

                            let rectAngle = obj.angle;

                            let ca = marginRight - TL.x;

                            let restrictedObjWidth = ca / Math.cos(degToRad(rectAngle));

                            let co = restrictedObjWidth * Math.sin(degToRad(rectAngle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = ML.x + ca / 2;

                            obj.top = ML.y + co / 2;

                        } else if (scaleYChanged) {

                            console.log("La esquina Top Right supera el margen derecho escalando verticalmente");

                            let rectAngle = obj.angle;

                            let co = marginRight - BR.x;

                            let restrictedObjectHeight = co / Math.sin(degToRad(rectAngle));

                            let ca = restrictedObjectHeight * Math.cos(degToRad(rectAngle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = MB.x + co / 2;

                            obj.top = MB.y - ca / 2;

                        }

                        break;

                    case 'BR_RIGHT':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen derecho escalando horizontal y verticalmente");

                            let offsetAngle = diagAngle - degToRad(360 - obj.angle);

                            let xOffset = BR.x - marginRight;

                            let yOffset = xOffset * Math.tan(offsetAngle);

                            let yCollision = BR.y - yOffset;

                            let collisionToAnchorWidth = marginRight - TL.x;

                            let collisionToAnchorHeight = yCollision - TL.y;

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = TL.x + collisionToAnchorWidth / 2;

                            obj.top = TL.y + collisionToAnchorHeight / 2;

                        } else if (scaleXChanged) {

                            console.log("La esquina Bottom Right supera el margen derecho escalando horizontalmente");

                            let rectAngle = 360 - obj.angle;

                            let co = marginRight - BL.x;

                            let restrictedObjWidth = co / Math.cos(degToRad(rectAngle));

                            let ca = restrictedObjWidth * Math.sin(degToRad(rectAngle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = ML.x + co / 2;

                            obj.top = ML.y - ca / 2;

                        } else if (scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen derecho escalando verticalmente");

                            let rectAngle = 360 - obj.angle;

                            let ca = marginRight - TR.x;

                            let restrictedObjectHeight = ca / Math.sin(degToRad(rectAngle));

                            let co = restrictedObjectHeight * Math.cos(degToRad(rectAngle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = MT.x + ca / 2;

                            obj.top = MT.y + co / 2;

                        }

                        break;

                    case 'BL_RIGHT':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Bottom Left supera el margen derecho escalando horizontal y verticalmente");

                            let offsetAngle = diagAngle - degToRad(obj.angle - 180);

                            let xOffset = BL.x - marginRight;

                            let yOffset = xOffset * Math.tan(offsetAngle);

                            let yCollision = BL.y + yOffset;

                            let collisionToAnchorWidth = marginRight - TR.x;

                            let collisionToAnchorHeight = yCollision - TR.y;

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = TR.x + collisionToAnchorWidth / 2;

                            obj.top = TR.y + collisionToAnchorHeight / 2;

                        } else if (scaleXChanged) {

                            console.log("La esquina Bottom Left supera el margen derecho escalando horizontalmente");

                            let rectAngle = obj.angle - 180;

                            let ca = marginRight - BR.x;

                            let restrictedObjWidth = ca / Math.cos(degToRad(rectAngle));

                            let co = restrictedObjWidth * Math.sin(degToRad(rectAngle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Encontrar el punto deseado de Top Left

                            obj.left = MR.x + ca / 2;

                            obj.top = MR.y + co / 2;

                        } else if (scaleYChanged) {

                            console.log("La esquina Bottom Left supera el margen derecho escalando verticalmente");

                            let rectAngle = obj.angle - 180;

                            let co = marginRight - TL.x;

                            let restrictedObjectHeight = co / Math.sin(degToRad(rectAngle));

                            let ca = restrictedObjectHeight * Math.cos(degToRad(rectAngle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = MT.x + co / 2;

                            obj.top = MT.y - ca / 2;

                        }

                        break;

                    case 'TL_BOTTOM':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Top Left supera el margen inferior escalando horizontal y verticalmente");

                            let offsetAngle = diagAngle - degToRad(270 - obj.angle);

                            let yOffset = TL.y - marginBottom;

                            let xOffset = yOffset * Math.tan(offsetAngle);

                            let xCollision = TL.x + xOffset;

                            let collisionToAnchorWidth = xCollision - BR.x;

                            let collisionToAnchorHeight = marginBottom - BR.y;

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = BR.x + collisionToAnchorWidth / 2;

                            obj.top = BR.y + collisionToAnchorHeight / 2;

                        } else if (scaleXChanged) {

                            console.log("La esquina Top Left supera el margen inferior escalando horizontalmente");

                            let rectAngle = obj.angle - 180;

                            let co = marginBottom - TR.y;

                            let restrictedObjWidth = co / Math.sin(degToRad(rectAngle));

                            let ca = restrictedObjWidth * Math.cos(degToRad(rectAngle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = MR.x + ca / 2;

                            obj.top = MR.y + co / 2;

                        } else if (scaleYChanged) {

                            console.log("La esquina Top Left supera el margen inferior escalando verticalmente");

                            let rectAngle = obj.angle - 180;

                            let ca = marginBottom - BL.y;

                            let restrictedObjectHeight = ca / Math.cos(degToRad(rectAngle));

                            let co = restrictedObjectHeight * Math.sin(degToRad(rectAngle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = MB.x - co / 2;

                            obj.top = MB.y + ca / 2;

                        }

                        break;

                    case 'TR_BOTTOM':

                        if (scaleXChanged && scaleYChanged) {


                            console.log("La esquina Top Right supera el margen inferior escalando horizontal y verticalmente");

                            let offsetAngle = diagAngle - degToRad(obj.angle - 90);

                            let yOffset = TR.y - marginBottom;

                            let xOffset = yOffset * Math.tan(offsetAngle);

                            let xCollision = TR.x - xOffset;

                            let collisionToAnchorWidth = xCollision - BL.x;

                            let collisionToAnchorHeight = marginBottom - BL.y;

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = BL.x + collisionToAnchorWidth / 2;

                            obj.top = BL.y + collisionToAnchorHeight / 2;

                        } else if (scaleXChanged) {

                            console.log("La esquina Top Right supera el margen inferior escalando horizontalmente");

                            let rectAngle = obj.angle - 90;

                            let ca = (marginBottom - TL.y);

                            let restrictedObjWidth = ca / Math.cos(degToRad(rectAngle));

                            let co = restrictedObjWidth * Math.sin(degToRad(rectAngle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = ML.x - co / 2;

                            obj.top = ML.y + ca / 2;

                        } else if (scaleYChanged) {

                            console.log("La esquina Top Right supera el margen inferior escalando verticalmente");

                            let rectAngle = obj.angle - 90;

                            let co = (marginBottom - BR.y);

                            let restrictedObjectHeight = co / Math.sin(degToRad(rectAngle));

                            let ca = restrictedObjectHeight * Math.cos(degToRad(rectAngle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = MB.x + ca / 2;

                            obj.top = MB.y + co / 2;

                        }

                        break;

                    case 'BR_BOTTOM':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen inferior escalando horizontal y verticalmente");

                            let offsetAngle = diagAngle - degToRad(90 - obj.angle);

                            let yOffset = BR.y - marginBottom;

                            let xOffset = yOffset * Math.tan(offsetAngle);

                            let xCollision = BR.x + xOffset;

                            let collisionToAnchorWidth = xCollision - TL.x;

                            let collisionToAnchorHeight = marginBottom - TL.y;

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = TL.x + collisionToAnchorWidth / 2;

                            obj.top = TL.y + collisionToAnchorHeight / 2;

                        } else if (scaleXChanged) {

                            console.log("La esquina Bottom Right supera el margen inferior escalando horizontalmente");

                            let rectAngle = obj.angle;

                            let co = (marginBottom - BL.y);

                            let restrictedObjWidth = co / Math.sin(degToRad(rectAngle));

                            let ca = restrictedObjWidth * Math.cos(degToRad(rectAngle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = ML.x + ca / 2;

                            obj.top = ML.y + co / 2;

                        } else if (scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen inferior escalando verticalmente");

                            let rectAngle = obj.angle;

                            let ca = marginBottom - TR.y;

                            let restrictedObjectHeight = ca / Math.cos(degToRad(rectAngle));

                            let co = restrictedObjectHeight * Math.sin(degToRad(rectAngle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = MT.x - co / 2;

                            obj.top = MT.y + ca / 2;

                        }

                        break;

                    case 'BL_BOTTOM':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen inferior escalando horizontal y verticalmente");

                            let offsetAngle = diagAngle - degToRad(obj.angle - 270);

                            let yOffset = BL.y - marginBottom;

                            let xOffset = yOffset * Math.tan(offsetAngle);

                            let xCollision = BL.x - xOffset;

                            let collisionToAnchorWidth = xCollision - TR.x;

                            let collisionToAnchorHeight = marginBottom - TR.y;

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = TR.x + collisionToAnchorWidth / 2;

                            obj.top = TR.y + collisionToAnchorHeight / 2;

                        } else if (scaleXChanged) {

                            console.log("La esquina Bottom Right supera el margen inferior escalando horizontalmente");

                            let rectAngle = obj.angle - 270;

                            let ca = marginBottom - BR.y;

                            let restrictedObjWidth = ca / Math.cos(degToRad(rectAngle));

                            let co = restrictedObjWidth * Math.sin(degToRad(rectAngle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = MR.x - co / 2;

                            obj.top = MR.y + ca / 2;

                        } else if (scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen inferior escalando verticalmente");

                            let rectAngle = obj.angle - 270;

                            let co = (marginBottom - TL.y);

                            let restrictedObjectHeight = co / Math.sin(degToRad(rectAngle));

                            let ca = restrictedObjectHeight * Math.cos(degToRad(rectAngle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = MT.x + ca / 2;

                            obj.top = MT.y + co / 2;

                        }

                        break;

                    case 'TL_LEFT':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Top Left supera el margen izquierdo escalando horizontal y verticalmente");

                            let offsetAngle = diagAngle - degToRad(360 - obj.angle);

                            let xOffset = marginRect.left - TL.x;

                            let yOffset = xOffset * Math.tan(offsetAngle);

                            let yCollision = TL.y + yOffset;

                            let collisionToAnchorWidth = BR.x - marginRect.left;

                            let collisionToAnchorHeight = yCollision - BR.y;

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = BR.x - collisionToAnchorWidth / 2;

                            obj.top = BR.y + collisionToAnchorHeight / 2;

                        } else if (scaleXChanged) {

                            console.log("La esquina Top Left supera el margen izquierdo escalando horizontalmente");

                            let rectAngle = obj.angle - 270;

                            let co = TR.x - marginRect.left;

                            let restrictedObjWidth = co / Math.sin(degToRad(rectAngle));

                            let ca = restrictedObjWidth * Math.cos(degToRad(rectAngle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = MR.x - co / 2;

                            obj.top = MR.y + ca / 2;

                        } else if (scaleYChanged) {

                            console.log("La esquina Top Left supera el margen izquierdo escalando verticalmente");

                            let rectAngle = obj.angle - 270;

                            let ca = BL.x - marginRect.left;

                            let restrictedObjectHeight = ca / Math.cos(degToRad(rectAngle));

                            let co = restrictedObjectHeight * Math.sin(degToRad(rectAngle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = MB.x - ca / 2;

                            obj.top = MB.y - co / 2;

                        }

                        break;

                    case 'TR_LEFT':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Top Left supera el margen izquierdo escalando horizontal y verticalmente");

                            let offsetAngle = diagAngle - degToRad(obj.angle - 180);

                            let xOffset = marginRect.left - TR.x;

                            let yOffset = xOffset * Math.tan(offsetAngle);

                            let yCollision = TR.y - yOffset;

                            let collisionToAnchorWidth = BL.x - marginRect.left;

                            let collisionToAnchorHeight = yCollision - BL.y;

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = BL.x - collisionToAnchorWidth / 2;

                            obj.top = BL.y + collisionToAnchorHeight / 2;

                        } else if (scaleXChanged) {

                            console.log("La esquina Top Left supera el margen izquierdo escalando horizontalmente");

                            let rectAngle = obj.angle - 180;

                            let ca = TL.x - marginRect.left;

                            let restrictedObjWidth = ca / Math.cos(degToRad(rectAngle));

                            let co = restrictedObjWidth * Math.sin(degToRad(rectAngle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = ML.x - ca / 2;

                            obj.top = ML.y - co / 2;

                        } else if (scaleYChanged) {

                            console.log("La esquina Top Left supera el margen izquierdo escalando verticalmente");

                            let rectAngle = obj.angle - 180;

                            let co = BR.x - marginRect.left;

                            let restrictedObjectHeight = co / Math.sin(degToRad(rectAngle));

                            let ca = restrictedObjectHeight * Math.cos(degToRad(rectAngle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = MB.x - co / 2;

                            obj.top = MB.y + ca / 2;

                        }

                        break;

                    case 'BR_LEFT':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen izquierdo escalando horizontal y verticalmente");

                            let offsetAngle = diagAngle - degToRad(180 - obj.angle);

                            let xOffset = marginRect.left - BR.x;

                            let yOffset = xOffset * Math.tan(offsetAngle);

                            let yCollision = BR.y + yOffset;

                            let collisionToAnchorWidth = TL.x - marginRect.left;

                            let collisionToAnchorHeight = yCollision - TL.y;

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = TL.x - collisionToAnchorWidth / 2;

                            obj.top = TL.y + collisionToAnchorHeight / 2;

                        } else if (scaleXChanged) {

                            console.log("La esquina Bottom Right supera el margen izquierdo escalando horizontalmente");

                            let rectAngle = obj.angle - 90;

                            let co = BL.x - marginRect.left;

                            let restrictedObjWidth = co / Math.sin(degToRad(rectAngle));

                            let ca = restrictedObjWidth * Math.cos(degToRad(rectAngle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = ML.x - co / 2;

                            obj.top = ML.y + ca / 2;

                        } else if (scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen izquierdo escalando verticalmente");

                            let rectAngle = obj.angle - 90;

                            let ca = TR.x - marginRect.left;

                            let restrictedObjectHeight = ca / Math.cos(degToRad(rectAngle));

                            let co = restrictedObjectHeight * Math.sin(degToRad(rectAngle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = MT.x - ca / 2;

                            obj.top = MT.y - co / 2;

                        }

                        break;

                    case 'BL_LEFT':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Bottom Left supera el margen izquierdo escalando horizontal y verticalmente");

                            let offsetAngle = diagAngle - degToRad(obj.angle);

                            let xOffset = marginRect.left - BL.x;

                            let yOffset = xOffset * Math.tan(offsetAngle);

                            let yCollision = BL.y - yOffset;

                            let collisionToAnchorWidth = TR.x - marginRect.left;

                            let collisionToAnchorHeight = yCollision - TR.y;

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = TR.x - collisionToAnchorWidth / 2;

                            obj.top = TR.y + collisionToAnchorHeight / 2;

                        } else if (scaleXChanged) {

                            console.log("La esquina Bottom Left supera el margen izquierdo escalando horizontalmente");

                            let rectAngle = obj.angle;

                            let ca = BR.x - marginRect.left;

                            let restrictedObjWidth = ca / Math.cos(degToRad(rectAngle));

                            let co = restrictedObjWidth * Math.sin(degToRad(rectAngle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = MR.x - ca / 2;

                            obj.top = MR.y - co / 2;

                        } else if (scaleYChanged) {

                            console.log("La esquina Bottom Left supera el margen izquierdo escalando verticalmente");

                            let rectAngle = obj.angle;

                            let co = TL.x - marginRect.left;

                            let restrictedObjectHeight = co / Math.sin(degToRad(rectAngle));

                            let ca = restrictedObjectHeight * Math.cos(degToRad(rectAngle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = MT.x - co / 2;

                            obj.top = MT.y + ca / 2;

                        }

                        break;

                    case 'TL_TOP':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Top Left supera el margen superior escalando horizontal y verticalmente");

                            let offsetAngle = diagAngle - degToRad(90 - obj.angle);

                            let yOffset = marginRect.top - TL.y;

                            let xOffset = yOffset * Math.tan(offsetAngle);

                            let xCollision = TL.x - xOffset;

                            let collisionToAnchorHeight = BR.y - marginRect.top;

                            let collisionToAnchorWidth = xCollision - BR.x;

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = BR.x + collisionToAnchorWidth / 2;

                            obj.top = BR.y - collisionToAnchorHeight / 2;

                        } else if (scaleXChanged) {

                            console.log("La esquina Top Left supera el margen superior escalando horizontalmente");

                            let rectAngle = obj.angle;

                            let co = TR.y - marginRect.top;

                            let restrictedObjWidth = co / Math.sin(degToRad(rectAngle));

                            let ca = restrictedObjWidth * Math.cos(degToRad(rectAngle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = MR.x - ca / 2;

                            obj.top = MR.y - co / 2;

                        } else if (scaleYChanged) {

                            console.log("La esquina Top Left supera el margen superior escalando verticalmente");

                            let rectAngle = obj.angle;

                            let ca = BL.y - marginRect.top;

                            let restrictedObjectHeight = ca / Math.cos(degToRad(rectAngle));

                            let co = restrictedObjectHeight * Math.sin(degToRad(rectAngle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = MB.x + co / 2;

                            obj.top = MB.y - ca / 2;

                        }

                        break;

                    case 'TR_TOP':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Top Right supera el margen superior escalando horizontal y verticalmente");

                            let offsetAngle = diagAngle - degToRad(obj.angle - 270);

                            let yOffset = marginRect.top - TR.y;

                            let xOffset = yOffset * Math.tan(offsetAngle);

                            let xCollision = TR.x + xOffset;

                            let collisionToAnchorHeight = BL.y - marginRect.top;

                            let collisionToAnchorWidth = xCollision - BL.x;

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = BL.x + collisionToAnchorWidth / 2;

                            obj.top = BL.y - collisionToAnchorHeight / 2;

                        } else if (scaleXChanged) {

                            console.log("La esquina Top Right supera el margen superior escalando horizontalmente");

                            let rectAngle = obj.angle - 270;

                            let ca = TL.y - marginRect.top;

                            let restrictedObjWidth = ca / Math.cos(degToRad(rectAngle));

                            let co = restrictedObjWidth * Math.sin(degToRad(rectAngle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = ML.x + co / 2;

                            obj.top = ML.y - ca / 2;

                        } else if (scaleYChanged) {

                            console.log("La esquina Top Right supera el margen superior escalando verticalmente");

                            let rectAngle = obj.angle - 270;

                            let co = BR.y - marginRect.top;

                            let restrictedObjectHeight = co / Math.sin(degToRad(rectAngle));

                            let ca = restrictedObjectHeight * Math.cos(degToRad(rectAngle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = MB.x - ca / 2;

                            obj.top = MB.y - co / 2;

                        }

                        break;

                    case 'BR_TOP':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen superior escalando horizontal y verticalmente");

                            let offsetAngle = diagAngle - degToRad(270 - obj.angle);

                            let yOffset = marginRect.top - BR.y;

                            let xOffset = yOffset * Math.tan(offsetAngle);

                            let xCollision = BR.x - xOffset;

                            let collisionToAnchorHeight = TL.y - marginRect.top;

                            let collisionToAnchorWidth = xCollision - TL.x;

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = TL.x + collisionToAnchorWidth / 2;

                            obj.top = TL.y - collisionToAnchorHeight / 2;

                        } else if (scaleXChanged) {

                            console.log("La esquina Bottom Right supera el margen superior escalando horizontalmente");

                            let rectAngle = obj.angle - 180;

                            let co = BL.y - marginRect.top;

                            let restrictedObjWidth = co / Math.sin(degToRad(rectAngle));

                            let ca = restrictedObjWidth * Math.cos(degToRad(rectAngle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = ML.x - ca / 2;

                            obj.top = ML.y - co / 2;

                        } else if (scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen superior escalando verticalmente");

                            let rectAngle = obj.angle - 180;

                            let ca = TR.y - marginRect.top;

                            let restrictedObjectHeight = ca / Math.cos(degToRad(rectAngle));

                            let co = restrictedObjectHeight * Math.sin(degToRad(rectAngle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = MT.x + co / 2;

                            obj.top = MT.y - ca / 2;
                        }

                        break;

                    case 'BL_TOP':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Bottom Left supera el margen superior escalando horizontal y verticalmente");

                            let offsetAngle = diagAngle - degToRad(obj.angle - 90);

                            let yOffset = marginRect.top - BL.y;

                            let xOffset = yOffset * Math.tan(offsetAngle);

                            let xCollision = BL.x + xOffset;

                            let collisionToAnchorHeight = TR.y - marginRect.top;

                            let collisionToAnchorWidth = xCollision - TR.x;

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = TR.x + collisionToAnchorWidth / 2;

                            obj.top = TR.y - collisionToAnchorHeight / 2;

                        } else if (scaleXChanged) {

                            console.log("La esquina Bottom Left supera el margen superior escalando horizontalmente");

                            let rectAngle = obj.angle - 90;

                            let ca = BR.y - marginRect.top;

                            let restrictedObjWidth = ca / Math.cos(degToRad(rectAngle));

                            let co = restrictedObjWidth * Math.sin(degToRad(rectAngle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = MR.x + co / 2;

                            obj.top = MR.y - ca / 2;

                        } else if (scaleYChanged) {

                            console.log("La esquina Bottom Left supera el margen superior escalando verticalmente");

                            let rectAngle = obj.angle - 90;

                            let co = TL.y - marginRect.top;

                            let restrictedObjectHeight = co / Math.sin(degToRad(rectAngle));

                            let ca = restrictedObjectHeight * Math.cos(degToRad(rectAngle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = MT.x - ca / 2;

                            obj.top = MT.y - co / 2;

                        }

                        break;

                    default:
                        // Handle default case
                        break;
                }
            }

            checkPosition();

            // Guardamos la escala y posición válidas
            obj._lastScaleX = obj.scaleX;
            obj._lastScaleY = obj.scaleY;

            obj.setCoords();

            canvas.renderAll();
        });

        resizeCanvas('carta');

        // Calcular el ancho del margen

        let marginWidth = (canvas.width - marginRect.width) / 2;

    </script>
</body>

</html>