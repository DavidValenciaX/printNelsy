<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asistente de impresión de Imágenes</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 1.25rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .main-container {
            display: flex;
            gap: 1.25rem;
            align-items: flex-start;
        }

        #canvas-container {
            border: 1px solid black;
        }

        .button-container {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }

        .size-button,
        .control-button,
        .orientation-button {
            padding: 0.938rem 1.875rem;
            font-size: 1.125rem;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 0.313rem;
            transition: background-color 0.3s;
            width: 12.5rem;
        }

        .size-button:hover,
        .control-button:hover,
        .orientation-button:hover {
            background-color: #45a049;
        }

        .size-button:active,
        .control-button:active,
        .orientation-button:active {
            background-color: #3e8e41;
        }

        #imageLoader {
            display: none;
        }

        .control-button[for="imageLoader"] {
            display: inline-block;
            text-align: center;
        }

        .control-group input[type="checkbox"] {
            margin-right: 0.5rem;
            width: 1.25rem;
            height: 1.25rem;
            cursor: pointer;
        }

        .control-group input[type="checkbox"]:checked {
            background-color: #3e8e41;
            border-color: #3e8e41;
        }

        .control-group label {
            font-family: Arial, sans-serif;
            color: #333;
            cursor: pointer;
        }

        .zoom-controls {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            display: flex;
            gap: 1rem;
            z-index: 1000;
        }

        .zoom-btn {
            padding: 1.25rem 1.875rem;
            font-size: 1.5rem;
            width: 4rem;
            height: 4rem;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .zoom-btn i {
            font-size: 2rem;
        }

        .zoom-btn:hover {
            background-color: #45a049;
        }

        #main-content {
            transform-origin: center top;
            transition: transform 0.3s ease;
        }

        #confirmCrop {
            display: none;
            background-color: #4CAF50;
        }

        #cancelCrop {
            display: none;
            background-color: #f44336;
        }

        hr {
            border: none;
            border-top: 2px dashed darkgray;
            margin: 1.25rem 0;
            width: 12.5rem;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
</head>

<body>
    <div id="main-content">
        <div class="main-container">
            <div class="button-container">
                <label for="imageLoader" class="control-button">Cargar imágenes</label>
                <input type="file" id="imageLoader" accept="image/*" multiple aria-label="Cargar imágenes">
                <button type="button" id="deleteButton" class="control-button">Eliminar imagen</button>
                <button type="button" id="printButton" class="control-button">Imprimir</button>
                <hr>
                <button type="button" id="cropButton" class="control-button">Recortar imagen</button>
                <button type="button" id="confirmCrop" class="control-button">✓ Confirmar</button>
                <button type="button" id="cancelCrop" class="control-button">✗ Cancelar</button>
                <div class="control-group">
                    <input type="checkbox" id="rotateControl">
                    <label for="rotateControl">Permitir rotación libre</label>
                </div>
            </div>
            <div id="canvas-container">
                <canvas id="canvas"></canvas>
            </div>
            <div class="button-container">
                <button type="button" class="size-button" id="cartaButton">CARTA</button>
                <button type="button" class="size-button" id="oficioButton">OFICIO</button>
                <button type="button" class="orientation-button" id="verticalButton">▯ Vertical</button>
                <button type="button" class="orientation-button" id="horizontalButton">▭ Horizontal</button>
                <button type="button" id="rotateButton+90" class="control-button">Girar 90 grados a la derecha
                    ↻</button>
                <button type="button" id="rotateButton-90" class="control-button">Girar 90 grados a la izquierda
                    ↺</button>
            </div>
        </div>
    </div>

    <div class="zoom-controls">
        <button type="button" class="zoom-btn" onclick="zoomIn()" title="Aumentar zoom">
            <i class="fas fa-search-plus"></i>
        </button>
        <button type="button" class="zoom-btn" onclick="zoomOut()" title="Reducir zoom">
            <i class="fas fa-search-minus"></i>
        </button>
    </div>

    <script>
        let currentZoom = 1;
        const zoomFactor = 0.1;
        const maxZoom = 2;
        const minZoom = 0.5;

        function zoomIn() {
            if (currentZoom < maxZoom) {
                currentZoom += zoomFactor;
                applyZoom();
            }
        }

        function zoomOut() {
            if (currentZoom > minZoom) {
                currentZoom -= zoomFactor;
                applyZoom();
            }
        }

        function applyZoom() {
            document.getElementById('main-content').style.transform = `scale(${currentZoom})`;
        }

        const canvasElement = document.getElementById('canvas');
        let canvas = new fabric.Canvas('canvas');
        const imageLoader = document.getElementById('imageLoader');
        const deleteButton = document.getElementById('deleteButton');
        const printButton = document.getElementById('printButton');
        const cartaButton = document.getElementById('cartaButton');
        const oficioButton = document.getElementById('oficioButton');
        const verticalButton = document.getElementById('verticalButton');
        const horizontalButton = document.getElementById('horizontalButton');
        const rotateButton_p90 = document.getElementById('rotateButton+90');
        const rotateButton_n90 = document.getElementById('rotateButton-90');

        const dpi = 300;
        const marginInches = 0.2;
        const marginPixels = marginInches * dpi;
        const paperSizes = {
            carta: { width: 8.5 * dpi, height: 11 * dpi },
            oficio: { width: 8.5 * dpi, height: 13 * dpi }
        };

        let currentSize = 'carta';
        let isVertical = true;
        let marginRect;

        let cropRect = null;
        let activeImage = null;
        let isCropping = false;
        let inactivatedObjects = [];

        function disableOtherObjects() {
            canvas.getObjects().forEach(obj => {
                if (obj !== activeImage && obj !== cropRect) {
                    inactivatedObjects.push({
                        object: obj,
                        originalOpacity: obj.opacity
                    });
                    obj.set({
                        opacity: 0.3,
                        selectable: false,
                        evented: false
                    });
                }
            });
            canvas.requestRenderAll();
        }

        function restoreOtherObjects() {
            inactivatedObjects.forEach(item => {
                item.object.set({
                    opacity: item.originalOpacity,
                    selectable: true,
                    evented: true
                });
            });
            inactivatedObjects = [];
            canvas.requestRenderAll();
        }

        document.getElementById('cropButton').addEventListener('click', function () {
            const activeObject = canvas.getActiveObject();
            if (!activeObject || activeObject.type !== 'image') return;

            enterCropMode(activeObject);
        });

        function enterCropMode(imgObject) {
            activeImage = imgObject;
            isCropping = true;

            // Create crop rectangle
            cropRect = new fabric.Rect({
                left: imgObject.left,
                top: imgObject.top,
                width: imgObject.width * imgObject.scaleX,
                height: imgObject.height * imgObject.scaleY,
                angle: imgObject.angle,
                fill: 'transparent',
                stroke: '#000',
                strokeWidth: 1,
                strokeDashArray: [5, 5],
                absolutePositioned: true,
                lockMovementX: true,
                lockMovementY: true,
                lockRotation: true,
                transparentCorners: false,
                cornerColor: 'DodgerBlue',
                cornerStyle: 'circle',
                cornerSize: 12,
                cornerStrokeColor: 'Blue'
            });

            canvas.add(cropRect);

            // Bring both objects to front
            imgObject.bringToFront();
            cropRect.bringToFront();

            // Disable other objects
            disableOtherObjects();

            canvas.setActiveObject(cropRect);

            // Show crop control buttons
            document.getElementById('confirmCrop').style.display = 'inline';
            document.getElementById('cancelCrop').style.display = 'inline';
            document.getElementById('cropButton').style.display = 'none';
        }

        document.getElementById('confirmCrop').addEventListener('click', function () {
            if (!isCropping || !cropRect || !activeImage) return;

            // Get the cropping rectangle
            const rect = cropRect;
            const img = activeImage;

            rect.set('stroke', 'transparent');

            // Create new cropped image
            const cropped = new Image();
            cropped.src = canvas.toDataURL({
                left: rect.left,
                top: rect.top,
                width: rect.width * rect.scaleX,
                height: rect.height * rect.scaleY
            });

            cropped.onload = function () {
                // Remove old image and crop rectangle
                canvas.remove(img);
                canvas.remove(rect);

                // Create and add new cropped image
                const newImage = new fabric.Image(cropped);
                newImage.set({
                    left: rect.left,
                    top: rect.top,
                });
                newImage.setCoords();
                canvas.add(newImage);
                canvas.renderAll();
            };

            exitCropMode();
        });

        document.getElementById('cancelCrop').addEventListener('click', exitCropMode);

        function exitCropMode() {
            if (cropRect) {
                canvas.remove(cropRect);
                cropRect = null;
            }

            isCropping = false;
            activeImage = null;

            // Restore other objects
            restoreOtherObjects();

            // Hide crop control buttons
            document.getElementById('confirmCrop').style.display = 'none';
            document.getElementById('cancelCrop').style.display = 'none';
            document.getElementById('cropButton').style.display = 'inline';
        }

        document.body.addEventListener('click', function (event) {
            const canvasElement = canvas.getElement();
            const isOnCanvasElement = event.target === canvasElement;
            const isOnFabricControls = event.target.classList.contains('canvas-container') ||
                event.target.classList.contains('upper-canvas') ||
                event.target.classList.contains('lower-canvas');
            const isOnButton = event.target.tagName === 'BUTTON' ||
                event.target.closest('button') !== null;

            const isOnCheckbox = event.target.tagName === 'INPUT' &&
                event.target.type === 'checkbox';

            const isOnCheckBoxLabel = event.target.tagName === 'LABEL' &&
                event.target.htmlFor === 'rotateControl';

            if (!isOnCanvasElement && !isOnFabricControls && !isOnButton && !isOnCheckbox && !isOnCheckBoxLabel) {
                canvas.discardActiveObject();
                canvas.requestRenderAll();
            }
        });

        deleteButton.addEventListener('click', function () {
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                canvas.remove(activeObject);
                canvas.renderAll();
            }
        });

        // Add keyboard delete support
        document.addEventListener('keydown', function (event) {
            if (event.key === 'Delete') {
                const activeObject = canvas.getActiveObject();
                if (activeObject) {
                    canvas.remove(activeObject);
                    canvas.renderAll();
                }
            }
        });

        function degToRad(degrees) {
            return degrees * (Math.PI / 180);
        }

        function radToDeg(radians) {
            return radians * (180 / Math.PI);
        }

        function createCoordinateMarker(x, y, color = 'red') {
            const marker = new fabric.Circle({
                left: x,
                top: y,
                fill: color,
                radius: 5,
                selectable: false,
                evented: false,
                originX: 'center',
                originY: 'center'
            });

            canvas.add(marker);
            canvas.bringToFront(marker);
            return marker;
        }

        function createCoordinateLine(x1, y1, x2, y2, color = 'red') {
            const line = new fabric.Line([x1, y1, x2, y2], {
                stroke: color,
                strokeWidth: 1,
                selectable: false,
                evented: false
            });

            canvas.add(line);
            canvas.bringToFront(line);
            return line;
        }

        function resizeCanvas(size, orientation = isVertical) {
            currentSize = size;
            isVertical = orientation;
            const scale = 0.3;
            let width = paperSizes[size].width;
            let height = paperSizes[size].height;

            if (!isVertical) {
                [width, height] = [height, width];
            }

            canvas.setWidth(width * scale);
            canvas.setHeight(height * scale);

            if (marginRect) {
                canvas.remove(marginRect);
            }

            marginRect = new fabric.Rect({
                width: width * scale - (2 * marginPixels * scale),
                height: height * scale - (2 * marginPixels * scale),
                left: marginPixels * scale,
                top: marginPixels * scale,
                fill: 'transparent',
                stroke: 'gray',
                strokeWidth: 1,
                strokeDashArray: [5, 5],
                selectable: false,
                evented: false
            });

            canvas.add(marginRect);
            canvas.renderAll();

            // Actualizar los límites para todas las imágenes existentes
            canvas.forEachObject(function (obj) {
                if (obj !== marginRect) {
                    obj.setCoords();
                }
            });
        }

        function changeOrientation(vertical) {
            resizeCanvas(currentSize, vertical);
        }

        cartaButton.addEventListener('click', () => resizeCanvas('carta'));
        oficioButton.addEventListener('click', () => resizeCanvas('oficio'));
        verticalButton.addEventListener('click', () => changeOrientation(true));
        horizontalButton.addEventListener('click', () => changeOrientation(false));

        imageLoader.addEventListener('change', handleImageUpload);
        printButton.addEventListener('click', printCanvas);
        rotateButton_p90.addEventListener('click', function () {
            rotateImage(90);
        });

        rotateButton_n90.addEventListener('click', function () {
            rotateImage(270);
        });


        function handleImageUpload(e) {
            const files = e.target.files;
            for (const element of files) {
                const file = element;
                const reader = new FileReader();
                reader.onload = function (event) {
                    fabric.Image.fromURL(event.target.result, function (img) {

                        // Asignar un ID único a la imagen
                        img.id = `image-${Date.now()}`;

                        img.scaleToWidth(canvas.width / 2);
                        canvas.add(img);
                        canvas.centerObject(img);
                        canvas.setActiveObject(img);

                        canvas.renderAll();
                    });
                }
                reader.readAsDataURL(file);
            }
        }

        function printCanvas() {

            // Store original opacity
            const originalOpacity = marginRect.opacity;

            // Make margin invisible for printing
            marginRect.opacity = 0;
            canvas.renderAll();

            const dataUrl = canvas.toDataURL({
                format: 'png',
                quality: 1,
                multiplier: 1 / canvas.getZoom()
            });

            const windowContent = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Imprimir Canvas</title>
                    <meta name="viewport" content="width=device-width, initial-scale=1">
                    <style>
                        @page {
                            margin: 0;
                            size: auto;
                        }
                        body {
                            margin: 0;
                            padding: 0;
                        }
                        img {
                            width: 100%;
                            height: auto;
                            display: block;
                            margin: 0;
                        }
                    </style>
                </head>
                <body>
                    <img src="${dataUrl}">
                </body>
                </html>`;

            const printWin = window.open('', '', 'width=800,height=600');
            printWin.document.open();
            printWin.document.write(windowContent);
            printWin.document.close();
            printWin.setTimeout(function () {
                printWin.focus();
                printWin.print();
                printWin.close();
                marginRect.opacity = originalOpacity;
                canvas.renderAll();
            }, 250);
        }

        fabric.Object.prototype.transparentCorners = false;
        fabric.Object.prototype.cornerColor = 'limegreen';
        fabric.Object.prototype.cornerStrokeColor = 'black';
        fabric.Object.prototype.cornerStyle = 'rect';
        fabric.Object.prototype.cornerSize = 12;
        const controls = fabric.Object.prototype.controls;
        const rotateControls = controls.mtr;
        rotateControls.visible = false;

        // Add this logging function
        function logObjectState(obj) {
            const TL = obj.getPointByOrigin(0, 0);
            const TR = obj.getPointByOrigin(1, 0);
            const BL = obj.getPointByOrigin(0, 1);
            const BR = obj.getPointByOrigin(1, 1);

            console.log('=== Object State ===');
            console.log(`Angle: ${obj.angle.toFixed(2)}°`);
            console.log(`Scale: X=${obj.scaleX.toFixed(2)}, Y=${obj.scaleY.toFixed(2)}`);
            console.log('Corners:');
            console.log(`TL: (${TL.x.toFixed(0)}, ${TL.y.toFixed(0)})`);
            console.log(`TR: (${TR.x.toFixed(0)}, ${TR.y.toFixed(0)})`);
            console.log(`BL: (${BL.x.toFixed(0)}, ${BL.y.toFixed(0)})`);
            console.log(`BR: (${BR.x.toFixed(0)}, ${BR.y.toFixed(0)})`);
            console.log(`Active Restriction: ${activeRestriction}`);
            console.log('==================\n');
        }

        canvas.on('object:moving', function (e) {
            let obj = e.target;
            obj.setCoords(); // Actualiza las coordenadas del objeto

            // Obtener los puntos del objeto y del margen
            let objPoints = [obj.aCoords.tl, obj.aCoords.tr, obj.aCoords.br, obj.aCoords.bl];

            let marginRight = (marginRect.left + marginRect.width);
            let marginBottom = (marginRect.top + marginRect.height);

            // Inicializar desplazamientos
            let offsetX = 0, offsetY = 0;

            // Comprobar cada punto del objeto
            objPoints.forEach(function (point) {
                if (point.x < marginRect.left) {
                    offsetX = Math.max(offsetX, marginRect.left - point.x);
                }
                if (point.x > marginRight) {
                    offsetX = Math.min(offsetX, marginRight - point.x);
                }
                if (point.y < marginRect.top) {
                    offsetY = Math.max(offsetY, marginRect.top - point.y);
                }
                if (point.y > marginBottom) {
                    offsetY = Math.min(offsetY, marginBottom - point.y);
                }
            });

            // Aplicar desplazamientos si es necesario
            if (offsetX !== 0 || offsetY !== 0) {
                obj.left += offsetX;
                obj.top += offsetY;
                obj.setCoords(); // Actualiza las coordenadas después de ajustar la posición
            }
        });

        function bringToFront(options) {
            options.target.bringToFront();
        }

        // Add this variable outside the event handler
        let activeRestriction = null;

        canvas.on('object:scaling', function (e) {
            let obj = e.target;
            obj.setCoords();

            let realObjectWidth = obj.width * obj.scaleX;
            let realObjectHeight = obj.height * obj.scaleY;

            // Comparar valores previos y actuales de scaleX y scaleY
            const scaleXChanged = obj.scaleX !== obj._lastScaleX;
            const scaleYChanged = obj.scaleY !== obj._lastScaleY;

            // Verificamos si el objeto excede los márgenes

            let marginRight = (marginRect.left + marginRect.width);
            let marginBottom = (marginRect.top + marginRect.height);

            let TL = obj.aCoords.tl;
            let TR = obj.aCoords.tr;
            let BL = obj.aCoords.bl;
            let BR = obj.aCoords.br;

            // Para establecer la posición y el escalado de objeto hay que darle las propiedades left, top, scaleX y scaleY

            function checkPosition(point) {

                // Check if object is still violating margins
                if (activeRestriction === 'TL_RIGHT' && TL.x <= marginRight) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'TR_RIGHT' && TR.x <= marginRight) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'BR_RIGHT' && BR.x <= marginRight) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'BL_RIGHT' && BL.x <= marginRight) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'TL_BOTTOM' && TL.y <= marginBottom) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'TR_BOTTOM' && TR.y <= marginBottom) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'BR_BOTTOM' && BR.y <= marginBottom) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'BL_BOTTOM' && BL.y <= marginBottom) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'TL_LEFT' && TL.x >= marginRect.left) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'TR_LEFT' && TR.x >= marginRect.left) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'BR_LEFT' && BR.x >= marginRect.left) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'BL_LEFT' && BL.x >= marginRect.left) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'TL_TOP' && TL.y >= marginRect.top) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'TR_TOP' && TR.y >= marginRect.top) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'BR_TOP' && BR.y >= marginRect.top) {
                    activeRestriction = null;
                }
                if (activeRestriction === 'BL_TOP' && BL.y >= marginRect.top) {
                    activeRestriction = null;
                }


                // Check positions and set activeRestriction if not set
                if (!activeRestriction) {
                    if (TL.x > marginRight && obj.angle > 90 && obj.angle <= 180) {
                        activeRestriction = 'TL_RIGHT';
                    } else if (TR.x > marginRight && obj.angle >= 0 && obj.angle <= 90) {
                        activeRestriction = 'TR_RIGHT';
                    } else if (BR.x > marginRight && obj.angle >= 270 && obj.angle < 360) {
                        activeRestriction = 'BR_RIGHT';
                    } else if (BL.x > marginRight && obj.angle >= 180 && obj.angle < 270) {
                        activeRestriction = 'BL_RIGHT';
                    } else if (TL.y > marginBottom && obj.angle >= 180 && obj.angle < 270) {
                        activeRestriction = 'TL_BOTTOM';
                    } else if (TR.y > marginBottom && obj.angle > 90 && obj.angle <= 180) {
                        activeRestriction = 'TR_BOTTOM';
                    } else if (BR.y > marginBottom && obj.angle >= 0 && obj.angle <= 90) {
                        activeRestriction = 'BR_BOTTOM';
                    } else if (BL.y > marginBottom && obj.angle >= 270 && obj.angle < 360) {
                        activeRestriction = 'BL_BOTTOM';
                    } else if (TL.x < marginRect.left && obj.angle >= 270 && obj.angle < 360) {
                        activeRestriction = 'TL_LEFT';
                    } else if (TR.x < marginRect.left && obj.angle >= 180 && obj.angle < 270) {
                        activeRestriction = 'TR_LEFT';
                    } else if (BR.x < marginRect.left && obj.angle >= 90 && obj.angle < 180) {
                        activeRestriction = 'BR_LEFT';
                    } else if (BL.x < marginRect.left && obj.angle >= 0 && obj.angle < 90) {
                        activeRestriction = 'BL_LEFT';
                    } else if (TL.y < marginRect.top && obj.angle >= 0 && obj.angle < 90) {
                        activeRestriction = 'TL_TOP';
                    } else if (TR.y < marginRect.top && obj.angle >= 270 && obj.angle < 360) {
                        activeRestriction = 'TR_TOP';
                    } else if (BR.y < marginRect.top && obj.angle >= 180 && obj.angle < 270) {
                        activeRestriction = 'BR_TOP';
                    } else if (BL.y < marginRect.top && obj.angle >= 90 && obj.angle < 180) {
                        activeRestriction = 'BL_TOP';
                    }
                }

                switch (activeRestriction) {
                    case 'TL_RIGHT':
                        // Handle TL.x > marginRight case

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Top Left supera el margen derecho escalando horizontal y verticalmente");

                            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

                            let offsetAngle = diagAngle - degToRad(180 - obj.angle);

                            let xOffset = TL.x - marginRight;

                            let yOffset = xOffset * Math.tan(offsetAngle);

                            let yCollision = TL.y - yOffset;

                            let collisionToAnchorWidth = Math.abs(marginRight - BR.x);

                            let collisionToAnchorHeight = Math.abs(BR.y - yCollision);

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = marginRight;

                            obj.top = yCollision;

                        } else if (scaleXChanged) {

                            console.log("La esquina Top Left supera el margen derecho escalando horizontalmente");

                            let co = (marginRight - TR.x);

                            let restrictedObjWidth = co / Math.sin(degToRad(obj.angle - 90));

                            let ca = restrictedObjWidth * Math.cos(degToRad(obj.angle - 90));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = marginRight;

                            obj.top = TR.y - ca;

                        } else if (scaleYChanged) {

                            console.log("La esquina Top Left supera el margen derecho escalando verticalmente");

                            let ca = marginRight - BL.x;

                            let restrictedObjectHeight = ca / Math.cos(degToRad(obj.angle - 90));

                            let co = restrictedObjectHeight * Math.sin(degToRad(obj.angle - 90));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = marginRight;

                            obj.top = BL.y + co;

                        }

                        break;

                    case 'TR_RIGHT':

                        // Handle TR.x > marginRight case
                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Top Right supera el margen derecho escalando horizontal y verticalmente");

                            // hallar angulo de la diagonal desde la base a la diagonal del rectangulo

                            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

                            let offsetAngle = diagAngle - degToRad(obj.angle);

                            let xOffset = TR.x - marginRight;

                            let yOffset = xOffset * Math.tan(offsetAngle);

                            let yCollision = Math.abs(TR.y + yOffset);

                            // Calcular las escalas x y y restringidas

                            // Calcular la distancia de la diagonal del rectangulo restringido

                            let collisionToAnchorWidth = Math.abs(marginRight - BL.x);

                            let collisionToAnchorHeight = Math.abs(yCollision - BL.y);

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            let ca = restrictedObjectHeight * Math.cos(degToRad(obj.angle));

                            let co = restrictedObjectHeight * Math.sin(degToRad(obj.angle));

                            obj.left = BL.x + co;

                            obj.top = BL.y - ca;

                        } else if (scaleXChanged) {

                            console.log("La esquina Top Right supera el margen derecho escalando horizontalmente");

                            let ca = (marginRight - TL.x);

                            let restrictedObjWidth = ca / Math.cos(degToRad(obj.angle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            obj.left = TL.x;

                            obj.top = TL.y;

                        } else if (scaleYChanged) {

                            console.log("La esquina Top Right supera el margen derecho escalando verticalmente");

                            let co = marginRight - BR.x;

                            let restrictedObjectHeight = co / Math.sin(degToRad(obj.angle));

                            let ca = restrictedObjectHeight * Math.cos(degToRad(obj.angle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = BL.x + co;

                            obj.top = BL.y - ca;

                        }

                        break;

                    case 'BR_RIGHT':

                        // Handle BR.x > marginRight case
                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen derecho escalando horizontal y verticalmente");

                            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

                            let offsetAngle = diagAngle - degToRad(360 - obj.angle);

                            let xOffset = BR.x - marginRight;

                            let yOffset = xOffset * Math.tan(offsetAngle);

                            let yCollision = BR.y - yOffset;

                            let collisionToAnchorWidth = Math.abs(marginRight - TL.x);

                            let collisionToAnchorHeight = Math.abs(yCollision - TL.y);

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // No hay necesidad de calcular el punto deseado de Top Left porque el punto Top left es el ancla, es decir que no se mueve

                        } else if (scaleXChanged) {

                            console.log("La esquina Bottom Right supera el margen derecho escalando horizontalmente");

                            let restrictedObjWidth = (marginRight - BL.x) / Math.cos(degToRad(360 - obj.angle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;
                        } else if (scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen derecho escalando verticalmente");

                            let restrictedObjectHeight = (marginRight - TR.x) / Math.sin(degToRad(360 - obj.angle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                        }

                        break;

                    case 'BL_RIGHT':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Bottom Left supera el margen derecho escalando horizontal y verticalmente");

                            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

                            let offsetAngle = diagAngle - degToRad(obj.angle - 180);

                            let xOffset = BL.x - marginRight;

                            let yOffset = xOffset * Math.tan(offsetAngle);

                            let yCollision = BL.y + yOffset;

                            let collisionToAnchorWidth = Math.abs(marginRight - TR.x);

                            let collisionToAnchorHeight = Math.abs(TR.y - yCollision);

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            let co = restrictedObjectWidth * Math.sin(degToRad(obj.angle - 180));

                            let ca = restrictedObjectWidth * Math.cos(degToRad(obj.angle - 180));

                            obj.left = TR.x + ca;

                            obj.top = TR.y + co;

                        } else if (scaleXChanged) {

                            console.log("La esquina Bottom Left supera el margen derecho escalando horizontalmente");

                            let ca = (marginRight - BR.x);

                            let restrictedObjWidth = ca / Math.cos(degToRad(obj.angle - 180));

                            let co = restrictedObjWidth * Math.sin(degToRad(obj.angle - 180));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Encontrar el punto deseado de Top Left

                            obj.left = TR.x + ca;

                            obj.top = TR.y + co;

                        } else if (scaleYChanged) {

                            console.log("La esquina Bottom Left supera el margen derecho escalando verticalmente");

                            let restrictedObjectHeight = (marginRight - TL.x) / Math.sin(degToRad(obj.angle - 180));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                        }

                        break;

                    case 'TL_BOTTOM':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Top Left supera el margen inferior escalando horizontal y verticalmente");

                            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

                            let offsetAngle = diagAngle - degToRad(270 - obj.angle);

                            let yOffset = TL.y - marginBottom;

                            let xOffset = yOffset * Math.tan(offsetAngle);

                            let xCollision = TL.x + xOffset;

                            let collisionToAnchorWidth = Math.abs(xCollision - BR.x);

                            let collisionToAnchorHeight = Math.abs(marginBottom - BR.y);

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = xCollision;

                            obj.top = marginBottom;

                        } else if (scaleXChanged) {

                            console.log("La esquina Top Left supera el margen inferior escalando horizontalmente");

                            let co = marginBottom - TR.y;

                            let restrictedObjWidth = co / Math.sin(degToRad(obj.angle - 180));

                            let ca = restrictedObjWidth * Math.cos(degToRad(obj.angle - 180));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = TR.x + ca;

                            obj.top = marginBottom;

                        } else if (scaleYChanged) {

                            console.log("La esquina Top Left supera el margen inferior escalando verticalmente");

                            let ca = marginBottom - BL.y;

                            let restrictedObjectHeight = ca / Math.cos(degToRad(obj.angle - 180));

                            let co = restrictedObjectHeight * Math.sin(degToRad(obj.angle - 180));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = BL.x - co;

                            obj.top = marginBottom;

                        }

                        break;

                    case 'TR_BOTTOM':
                        // Handle TR.y > marginBottom case

                        if (scaleXChanged && scaleYChanged) {


                            console.log("La esquina Top Right supera el margen inferior escalando horizontal y verticalmente");

                            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

                            let offsetAngle = diagAngle - degToRad(obj.angle - 90);

                            let yOffset = TR.y - marginBottom;

                            let xOffset = yOffset * Math.tan(offsetAngle);

                            let xCollision = TR.x - xOffset;

                            let collisionToAnchorWidth = Math.abs(xCollision - BL.x);

                            let collisionToAnchorHeight = Math.abs(marginBottom - BL.y);

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            let ca = restrictedObjectHeight * Math.cos(degToRad(obj.angle - 90));

                            let co = restrictedObjectHeight * Math.sin(degToRad(obj.angle - 90));

                            obj.left = BL.x + ca;

                            obj.top = BL.y + co;

                        } else if (scaleXChanged) {

                            console.log("La esquina Top Right supera el margen inferior escalando horizontalmente");

                            let ca = (marginBottom - TL.y);

                            let restrictedObjWidth = ca / Math.cos(degToRad(obj.angle - 90));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // No hay necesidad de calcular el punto deseado de Top Left porque el punto Top left es un ancla, es decir que no se mueve

                        } else if (scaleYChanged) {

                            console.log("La esquina Top Right supera el margen inferior escalando verticalmente");

                            let co = (marginBottom - BR.y);

                            let restrictedObjectHeight = co / Math.sin(degToRad(obj.angle - 90));

                            let ca = restrictedObjectHeight * Math.cos(degToRad(obj.angle - 90));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = BL.x + ca;

                            obj.top = BL.y + co;

                        }

                        break;

                    case 'BR_BOTTOM':

                        // Handle BR.y > marginBottom case
                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen inferior escalando horizontal y verticalmente");

                            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

                            let offsetAngle = diagAngle - degToRad(90 - obj.angle);

                            let yOffset = BR.y - marginBottom;

                            let xOffset = yOffset * Math.tan(offsetAngle);

                            let xCollision = BR.x + xOffset;

                            let collisionToAnchorWidth = Math.abs(xCollision - TL.x);

                            let collisionToAnchorHeight = Math.abs(marginBottom - TL.y);

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // No hay necesidad de calcular el punto deseado de Top Left porque el punto Top left es el ancla, es decir que no se mueve

                        } else if (scaleXChanged) {

                            console.log("La esquina Bottom Right supera el margen inferior escalando horizontalmente");

                            let co = (marginBottom - BL.y);

                            let restrictedObjWidth = co / Math.sin(degToRad(obj.angle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // No hay necesidad de calcular el punto deseado de Top Left porque el punto Top left es el ancla, es decir que no se mueve

                        } else if (scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen inferior escalando verticalmente");

                            let ca = marginBottom - TR.y;

                            let restrictedObjectHeight = ca / Math.cos(degToRad(obj.angle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // No hay necesidad de calcular el punto deseado de Top Left porque el punto Top left es el ancla, es decir que no se mueve

                        }

                        break;

                    case 'BL_BOTTOM':

                        // Handle BL.y > marginBottom case
                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen inferior escalando horizontal y verticalmente");

                            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

                            let offsetAngle = diagAngle - degToRad(obj.angle - 270);

                            let yOffset = BL.y - marginBottom;

                            let xOffset = yOffset * Math.tan(offsetAngle);

                            let xCollision = BL.x - xOffset;

                            let collisionToAnchorWidth = Math.abs(xCollision - TR.x);

                            let collisionToAnchorHeight = Math.abs(marginBottom - TR.y);

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            let co = restrictedObjectHeight * Math.sin(degToRad(obj.angle - 270));

                            let ca = restrictedObjectHeight * Math.cos(degToRad(obj.angle - 270));

                            obj.left = xCollision - ca;

                            obj.top = marginBottom - co;

                        } else if (scaleXChanged) {

                            console.log("La esquina Bottom Right supera el margen inferior escalando horizontalmente");

                            let ca = marginBottom - BR.y;

                            let restrictedObjWidth = ca / Math.cos(degToRad(obj.angle - 270));

                            let co = restrictedObjWidth * Math.sin(degToRad(obj.angle - 270));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = TR.x - co;

                            obj.top = TR.y + ca;

                        } else if (scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen inferior escalando verticalmente");

                            let co = (marginBottom - TL.y);

                            let restrictedObjectHeight = co / Math.sin(degToRad(obj.angle - 270));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // No hay necesidad de calcular el punto deseado de Top Left porque el punto Top left es el ancla, es decir que no se mueve

                        }

                        break;

                    case 'TL_LEFT':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Top Left supera el margen izquierdo escalando horizontal y verticalmente");

                            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

                            let offsetAngle = diagAngle - degToRad(360 - obj.angle);

                            let xOffset = marginRect.left - TL.x;

                            let yOffset = xOffset * Math.tan(offsetAngle);

                            let yCollision = TL.y + yOffset;

                            let collisionToAnchorWidth = Math.abs(BR.x - marginRect.left);

                            let collisionToAnchorHeight = Math.abs(yCollision - BR.y);

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = marginRect.left;

                            obj.top = yCollision;

                        } else if (scaleXChanged) {

                            console.log("La esquina Top Left supera el margen izquierdo escalando horizontalmente");

                            let co = TR.x - marginRect.left;

                            let restrictedObjWidth = co / Math.sin(degToRad(obj.angle - 270));

                            let ca = restrictedObjWidth * Math.cos(degToRad(obj.angle - 270));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = marginRect.left;

                            obj.top = TR.y + ca;

                        } else if (scaleYChanged) {

                            console.log("La esquina Top Left supera el margen izquierdo escalando verticalmente");

                            let ca = BL.x - marginRect.left;

                            let restrictedObjectHeight = ca / Math.cos(degToRad(obj.angle - 270));

                            let co = restrictedObjectHeight * Math.sin(degToRad(obj.angle - 270));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = marginRect.left;

                            obj.top = BL.y - co;

                        }

                        break;

                    case 'TR_LEFT':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Top Left supera el margen izquierdo escalando horizontal y verticalmente");

                            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

                            let offsetAngle = diagAngle - degToRad(obj.angle - 180);

                            let xOffset = marginRect.left - TR.x;

                            let yOffset = xOffset * Math.tan(offsetAngle);

                            let yCollision = TR.y - yOffset;

                            let collisionToAnchorWidth = Math.abs(BL.x - marginRect.left);

                            let collisionToAnchorHeight = Math.abs(yCollision - BL.y);

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            let co = restrictedObjectHeight * Math.sin(degToRad(obj.angle - 180));

                            let ca = restrictedObjectHeight * Math.cos(degToRad(obj.angle - 180));

                            obj.left = BL.x - co;

                            obj.top = BL.y + ca;

                        } else if (scaleXChanged) {

                            console.log("La esquina Top Left supera el margen izquierdo escalando horizontalmente");

                            let ca = TL.x - marginRect.left;

                            let restrictedObjWidth = ca / Math.cos(degToRad(obj.angle - 180));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // No hay necesidad de calcular el punto deseado de Top Left porque el punto Top left es el ancla, es decir que no se mueve

                        } else if (scaleYChanged) {

                            console.log("La esquina Top Left supera el margen izquierdo escalando verticalmente");

                            let co = BR.x - marginRect.left;

                            let restrictedObjectHeight = co / Math.sin(degToRad(obj.angle - 180));

                            let ca = restrictedObjectHeight * Math.cos(degToRad(obj.angle - 180));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = BL.x - co;

                            obj.top = BL.y + ca;

                        }

                        break;

                    case 'BR_LEFT':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen izquierdo escalando horizontal y verticalmente");

                            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

                            let offsetAngle = diagAngle - degToRad(180 - obj.angle);

                            let xOffset = marginRect.left - BR.x;

                            let yOffset = xOffset * Math.tan(offsetAngle);

                            let yCollision = BR.y + yOffset;

                            let collisionToAnchorWidth = Math.abs(TL.x - marginRect.left);

                            let collisionToAnchorHeight = Math.abs(yCollision - TL.y);

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // No hay necesidad de calcular el punto deseado de Top Left porque el punto Top left es el ancla, es decir que no se mueve

                        } else if (scaleXChanged) {

                            console.log("La esquina Bottom Right supera el margen izquierdo escalando horizontalmente");

                            let co = BL.x - marginRect.left;

                            let restrictedObjWidth = co / Math.sin(degToRad(obj.angle - 90));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // No hay necesidad de calcular el punto deseado de Top Left porque el punto Top left es el ancla, es decir que no se mueve

                        } else if (scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen izquierdo escalando verticalmente");

                            let ca = TR.x - marginRect.left;

                            let restrictedObjectHeight = ca / Math.cos(degToRad(obj.angle - 90));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // No hay necesidad de calcular el punto deseado de Top Left porque el punto Top left es el ancla, es decir que no se mueve

                        }

                        break;

                    case 'BL_LEFT':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Bottom Left supera el margen izquierdo escalando horizontal y verticalmente");

                            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

                            let offsetAngle = diagAngle - degToRad(obj.angle);

                            let xOffset = marginRect.left - BL.x;

                            let yOffset = xOffset * Math.tan(offsetAngle);

                            let yCollision = BL.y - yOffset;

                            let collisionToAnchorWidth = Math.abs(TR.x - marginRect.left);

                            let collisionToAnchorHeight = Math.abs(yCollision - TR.y);

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            let co = restrictedObjectWidth * Math.sin(degToRad(obj.angle));

                            let ca = restrictedObjectWidth * Math.cos(degToRad(obj.angle));

                            obj.left = TR.x - ca;

                            obj.top = TR.y - co;

                        } else if (scaleXChanged) {

                            console.log("La esquina Bottom Left supera el margen izquierdo escalando horizontalmente");

                            let ca = BR.x - marginRect.left;

                            let restrictedObjWidth = ca / Math.cos(degToRad(obj.angle));

                            let co = restrictedObjWidth * Math.sin(degToRad(obj.angle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = TR.x - ca;

                            obj.top = TR.y - co;

                        } else if (scaleYChanged) {

                            console.log("La esquina Bottom Left supera el margen izquierdo escalando verticalmente");

                            let co = TL.x - marginRect.left;

                            let restrictedObjectHeight = co / Math.sin(degToRad(obj.angle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // No hay necesidad de calcular el punto deseado de Top Left porque el punto Top left es el ancla, es decir que no se mueve

                        }

                        break;

                    case 'TL_TOP':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Top Left supera el margen superior escalando horizontal y verticalmente");

                            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

                            let offsetAngle = diagAngle - degToRad(90 - obj.angle);

                            let yOffset = marginRect.top - TL.y;

                            let xOffset = yOffset * Math.tan(offsetAngle);

                            let xCollision = TL.x - xOffset;

                            let collisionToAnchorWidth = Math.abs(BR.x - xCollision);

                            let collisionToAnchorHeight = Math.abs(BR.y - marginRect.top);

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = xCollision;

                            obj.top = marginRect.top;

                        } else if (scaleXChanged) {

                            console.log("La esquina Top Left supera el margen superior escalando horizontalmente");

                            let co = TR.y - marginRect.top;

                            let restrictedObjWidth = co / Math.sin(degToRad(obj.angle));

                            let ca = restrictedObjWidth * Math.cos(degToRad(obj.angle));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = TR.x - ca;

                            obj.top = marginRect.top;

                        } else if (scaleYChanged) {

                            console.log("La esquina Top Left supera el margen superior escalando verticalmente");

                            let ca = BL.y - marginRect.top;

                            let restrictedObjectHeight = ca / Math.cos(degToRad(obj.angle));

                            let co = restrictedObjectHeight * Math.sin(degToRad(obj.angle));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = BL.x + co;

                            obj.top = marginRect.top;

                        }

                        break;

                    case 'TR_TOP':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Top Right supera el margen superior escalando horizontal y verticalmente");

                            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

                            let offsetAngle = diagAngle - degToRad(obj.angle - 270);

                            let yOffset = marginRect.top - TR.y;

                            let xOffset = yOffset * Math.tan(offsetAngle);

                            let xCollision = TR.x + xOffset;

                            let collisionToAnchorWidth = Math.abs(BL.x - xCollision);

                            let collisionToAnchorHeight = Math.abs(BL.y - marginRect.top);

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            let co = restrictedObjectHeight * Math.sin(degToRad(obj.angle - 270));

                            let ca = restrictedObjectHeight * Math.cos(degToRad(obj.angle - 270));

                            obj.left = BL.x - ca;

                            obj.top = BL.y - co;

                        } else if (scaleXChanged) {

                            console.log("La esquina Top Right supera el margen superior escalando horizontalmente");

                            let ca = TL.y - marginRect.top;

                            let restrictedObjWidth = ca / Math.cos(degToRad(obj.angle - 270));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // No hay necesidad de calcular el punto deseado de Top Left porque el punto Top left es el ancla, es decir que no se mueve

                        } else if (scaleYChanged) {

                            console.log("La esquina Top Right supera el margen superior escalando verticalmente");

                            let co = BR.y - marginRect.top;

                            let restrictedObjectHeight = co / Math.sin(degToRad(obj.angle - 270));

                            let ca = restrictedObjectHeight * Math.cos(degToRad(obj.angle - 270));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            obj.left = BL.x - ca;

                            obj.top = BL.y - co;

                        }

                        break;

                    case 'BR_TOP':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen superior escalando horizontal y verticalmente");

                            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

                            let offsetAngle = diagAngle - degToRad(270 - obj.angle);

                            let yOffset = marginRect.top - BR.y;

                            let xOffset = yOffset * Math.tan(offsetAngle);

                            let xCollision = BR.x - xOffset;

                            let collisionToAnchorWidth = Math.abs(TL.x - xCollision);

                            let collisionToAnchorHeight = Math.abs(TL.y - marginRect.top);

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // No hay necesidad de calcular el punto deseado de Top Left porque el punto Top left es el ancla, es decir que no se mueve

                        } else if (scaleXChanged) {

                            console.log("La esquina Bottom Right supera el margen superior escalando horizontalmente");

                            let co = BL.y - marginRect.top;

                            let restrictedObjWidth = co / Math.sin(degToRad(obj.angle - 180));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // No hay necesidad de calcular el punto deseado de Top Left porque el punto Top left es el ancla, es decir que no se mueve

                        } else if (scaleYChanged) {

                            console.log("La esquina Bottom Right supera el margen superior escalando verticalmente");

                            let ca = TR.y - marginRect.top;

                            let restrictedObjectHeight = ca / Math.cos(degToRad(obj.angle - 180));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // No hay necesidad de calcular el punto deseado de Top Left porque el punto Top left es el ancla, es decir que no se mueve
                        }

                        break;

                    case 'BL_TOP':

                        if (scaleXChanged && scaleYChanged) {

                            console.log("La esquina Bottom Left supera el margen superior escalando horizontal y verticalmente");

                            let diagAngle = Math.atan(realObjectHeight / realObjectWidth);

                            let offsetAngle = diagAngle - degToRad(obj.angle - 90);

                            let yOffset = marginRect.top - BL.y;

                            let xOffset = yOffset * Math.tan(offsetAngle);

                            let xCollision = BL.x + xOffset;

                            let collisionToAnchorWidth = Math.abs(TR.x - xCollision);

                            let collisionToAnchorHeight = Math.abs(TR.y - marginRect.top);

                            let restrictedObjectDiagonal = Math.sqrt(Math.pow(collisionToAnchorWidth, 2) + Math.pow(collisionToAnchorHeight, 2));

                            let restrictedObjectWidth = restrictedObjectDiagonal * Math.cos(diagAngle);

                            let restrictedObjectHeight = restrictedObjectDiagonal * Math.sin(diagAngle);

                            let restrictedScaleX = restrictedObjectWidth / obj.width;

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleX = restrictedScaleX;

                            obj.scaleY = restrictedScaleY;

                            // Calculo del punto top y left

                            let ca = restrictedObjectWidth * Math.cos(degToRad(obj.angle - 90));

                            let co = restrictedObjectWidth * Math.sin(degToRad(obj.angle - 90));

                            obj.left = TR.x + co;

                            obj.top = TR.y - ca;

                        } else if (scaleXChanged) {

                            console.log("La esquina Bottom Left supera el margen superior escalando horizontalmente");

                            let ca = BR.y - marginRect.top;

                            let restrictedObjWidth = ca / Math.cos(degToRad(obj.angle - 90));

                            let co = restrictedObjWidth * Math.sin(degToRad(obj.angle - 90));

                            let restrictedScaleX = restrictedObjWidth / obj.width;

                            obj.scaleX = restrictedScaleX;

                            // Calculo del punto top y left

                            obj.left = TR.x + co;

                            obj.top = TR.y - ca;

                        } else if (scaleYChanged) {

                            console.log("La esquina Bottom Left supera el margen superior escalando verticalmente");

                            let co = TL.y - marginRect.top;

                            let restrictedObjectHeight = co / Math.sin(degToRad(obj.angle - 90));

                            let restrictedScaleY = restrictedObjectHeight / obj.height;

                            obj.scaleY = restrictedScaleY;

                            // No hay necesidad de calcular el punto deseado de Top Left porque el punto Top left es el ancla, es decir que no se mueve

                        }

                        break;

                    default:
                        // Handle default case
                        break;
                }
            }

            checkPosition();

            // Guardamos la escala y posición válidas
            obj._lastScaleX = obj.scaleX;
            obj._lastScaleY = obj.scaleY;

            obj.setCoords();

            canvas.renderAll();
        });

        // Reset activeRestriction when scaling ends
        canvas.on('object:modified', function (e) {
            activeRestriction = null;
        });

        canvas.on('object:rotating', function (e) {
            let obj = e.target;
            obj.setCoords(); // Actualiza las coordenadas del objeto

        });

        function rotateImage(deg) {
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                activeObject.rotate((activeObject.angle + deg) % 360);
                activeObject.setCoords();

                canvas.renderAll();
            }
        }

        // Get checkbox element
        const rotateCheckbox = document.getElementById('rotateControl');

        // Add event listener
        rotateCheckbox.addEventListener('change', function (e) {
            canvas.getObjects().forEach(obj => {

                if (obj.type === 'image') {
                    obj.setControlsVisibility({
                        mtr: this.checked
                    });
                }
            });
            canvas.requestRenderAll();
        });

        resizeCanvas('carta');
    </script>
</body>

</html>