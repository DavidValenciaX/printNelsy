<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Imágenes con Fabric.js</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .main-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        #canvas-container {
            border: 1px solid black;
        }

        .button-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .size-button,
        .control-button,
        .orientation-button {
            padding: 15px 30px;
            font-size: 18px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
            width: 200px;
        }

        .size-button:hover,
        .control-button:hover,
        .orientation-button:hover {
            background-color: #45a049;
        }

        .size-button:active,
        .control-button:active,
        .orientation-button:active {
            background-color: #3e8e41;
        }

        #imageLoader {
            display: none;
        }

        .control-button[for="imageLoader"] {
            display: inline-block;
            text-align: center;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
</head>

<body>
    <div class="main-container">
        <div class="button-container">
            <label for="imageLoader" class="control-button">Cargar imágenes</label>
            <input type="file" id="imageLoader" accept="image/*" multiple aria-label="Cargar imágenes">
            <button type="button" id="printButton" class="control-button">Imprimir</button>
        </div>
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        <div class="button-container">
            <button type="button" class="size-button" id="cartaButton">CARTA</button>
            <button type="button" class="size-button" id="oficioButton">OFICIO</button>
            <button type="button" class="orientation-button" id="verticalButton">▯ Vertical</button>
            <button type="button" class="orientation-button" id="horizontalButton">▭ Horizontal</button>
            <button type="button" id="rotateButton+90" class="control-button">Girar 90 grados a la derecha ↻</button>
            <button type="button" id="rotateButton-90" class="control-button">Girar 90 grados a la izquierda ↺</button>
        </div>
    </div>

    <script>
        const canvasElement = document.getElementById('canvas');
        let canvas = new fabric.Canvas('canvas');
        const imageLoader = document.getElementById('imageLoader');
        const printButton = document.getElementById('printButton');
        const cartaButton = document.getElementById('cartaButton');
        const oficioButton = document.getElementById('oficioButton');
        const verticalButton = document.getElementById('verticalButton');
        const horizontalButton = document.getElementById('horizontalButton');
        const rotateButton_p90 = document.getElementById('rotateButton+90');
        const rotateButton_n90 = document.getElementById('rotateButton-90');

        const dpi = 300;
        const marginInches = 0.2;
        const marginPixels = marginInches * dpi;
        const paperSizes = {
            carta: { width: 8.5 * dpi, height: 11 * dpi },
            oficio: { width: 8.5 * dpi, height: 13 * dpi }
        };

        let currentSize = 'carta';
        let isVertical = true;
        let marginRect;

        // Variable para almacenar los puntos rojos
        let coordinateMarkers = {};

        function degToRad(degrees) {
            return degrees * (Math.PI / 180);
        }

        function createCoordinateMarker(x, y, color = 'red', id = null) {
            const marker = new fabric.Circle({
                left: x,
                top: y,
                fill: color,
                radius: 5,
                selectable: false,
                evented: false,
                originX: 'center',
                originY: 'center'
            });

            if (id) {
                marker.id = id;
                coordinateMarkers[id] = marker;
            }

            canvas.add(marker);
            canvas.bringToFront(marker);
            return marker;
        }

        function updateCoordinateMarker(obj) {
            // Eliminar marcadores anteriores específicos de este objeto
            Object.keys(coordinateMarkers).forEach(key => {
                if (key.startsWith(`marker-${obj.id}`)) {
                    canvas.remove(coordinateMarkers[key]);
                    delete coordinateMarkers[key];
                }
            });

            // Obtener bounding rect para calcular objBoundingRight y objBoundingBottom
            const objBoundingRect = obj.getBoundingRect(true);

            // Crear marcadores para top-left
            createCoordinateMarker(objBoundingRect.left, objBoundingRect.top, 'red', `marker-${obj.id}-top-left`);

            const objBoundingRight = objBoundingRect.left + objBoundingRect.width;
            const objBoundingBottom = objBoundingRect.top + objBoundingRect.height;

            // Crear marcadores para right-bottom
            createCoordinateMarker(objBoundingRight, objBoundingBottom, 'blue', `marker-${obj.id}-right-bottom`);

            canvas.renderAll();
        }


        function resizeCanvas(size, orientation = isVertical) {
            currentSize = size;
            isVertical = orientation;
            const scale = 0.3;
            let width = paperSizes[size].width;
            let height = paperSizes[size].height;

            if (!isVertical) {
                [width, height] = [height, width];
            }

            canvas.setWidth(width * scale);
            canvas.setHeight(height * scale);

            if (marginRect) {
                canvas.remove(marginRect);
            }

            marginRect = new fabric.Rect({
                width: width * scale - (2 * marginPixels * scale),
                height: height * scale - (2 * marginPixels * scale),
                left: marginPixels * scale,
                top: marginPixels * scale,
                fill: 'transparent',
                stroke: 'gray',
                strokeWidth: 1,
                strokeDashArray: [5, 5],
                selectable: false,
                evented: false
            });

            canvas.add(marginRect);
            canvas.renderAll();

            // Actualizar los límites para todas las imágenes existentes
            canvas.forEachObject(function (obj) {
                if (obj !== marginRect) {
                    obj.setCoords();
                }
            });
        }

        function changeOrientation(vertical) {
            resizeCanvas(currentSize, vertical);
        }

        cartaButton.addEventListener('click', () => resizeCanvas('carta'));
        oficioButton.addEventListener('click', () => resizeCanvas('oficio'));
        verticalButton.addEventListener('click', () => changeOrientation(true));
        horizontalButton.addEventListener('click', () => changeOrientation(false));

        imageLoader.addEventListener('change', handleImageUpload);
        printButton.addEventListener('click', printCanvas);
        rotateButton_p90.addEventListener('click', function () {
            rotateImage(90);
        });

        rotateButton_n90.addEventListener('click', function () {
            rotateImage(-90);
        });


        function handleImageUpload(e) {
            const files = e.target.files;
            for (const element of files) {
                const file = element;
                const reader = new FileReader();
                reader.onload = function (event) {
                    fabric.Image.fromURL(event.target.result, function (img) {

                        // Asignar un ID único a la imagen
                        img.id = `image-${Date.now()}`;

                        img.scaleToWidth(canvas.width / 2);
                        canvas.add(img);
                        canvas.centerObject(img);
                        canvas.setActiveObject(img);

                        // Crear el marcador de coordenadas inicial
                        updateCoordinateMarker(img);

                        canvas.renderAll();
                    });
                }
                reader.readAsDataURL(file);
            }
        }

        function printCanvas() {
            const dataUrl = canvas.toDataURL({
                format: 'png',
                quality: 1,
                multiplier: 1 / canvas.getZoom()
            });
            const windowContent = '<!DOCTYPE html><html><head><title>Imprimir Canvas</title></head><body><img src="' + dataUrl + '" style="width:100%;"></body></html>';
            const printWin = window.open('', '', 'width=800,height=600');
            printWin.document.open();
            printWin.document.write(windowContent);
            printWin.document.close();
            printWin.setTimeout(function () {
                printWin.focus();
                printWin.print();
                printWin.close();
            }, 250);
        }

        fabric.Object.prototype.transparentCorners = false;
        fabric.Object.prototype.cornerColor = 'limegreen';
        fabric.Object.prototype.cornerStrokeColor = 'black';
        fabric.Object.prototype.cornerStyle = 'rect';
        fabric.Object.prototype.cornerSize = 12;
        const controls = fabric.Object.prototype.controls
        const rotateControls = controls.mtr
        rotateControls.visible = true

        canvas.on('object:moving', function (e) {
            let obj = e.target;
            obj.setCoords(); // Actualiza las coordenadas del objeto

            // Actualizar el marcador de coordenadas
            if (obj.id && obj.id.startsWith('image-')) {
                updateCoordinateMarker(obj);
            }

            // Obtener los puntos del objeto y del margen
            let objPoints = [obj.aCoords.tl, obj.aCoords.tr, obj.aCoords.br, obj.aCoords.bl];
            let marginPoints = marginRect.aCoords;

            // Calcular los límites del margen
            let marginMinX = Math.min(marginPoints.tl.x, marginPoints.tr.x, marginPoints.br.x, marginPoints.bl.x);
            let marginMaxX = Math.max(marginPoints.tl.x, marginPoints.tr.x, marginPoints.br.x, marginPoints.bl.x);
            let marginMinY = Math.min(marginPoints.tl.y, marginPoints.tr.y, marginPoints.br.y, marginPoints.bl.y);
            let marginMaxY = Math.max(marginPoints.tl.y, marginPoints.tr.y, marginPoints.br.y, marginPoints.bl.y);

            // Inicializar desplazamientos
            let offsetX = 0, offsetY = 0;

            // Comprobar cada punto del objeto
            objPoints.forEach(function (point) {
                if (point.x < marginMinX) {
                    offsetX = Math.max(offsetX, marginMinX - point.x);
                }
                if (point.x > marginMaxX) {
                    offsetX = Math.min(offsetX, marginMaxX - point.x);
                }
                if (point.y < marginMinY) {
                    offsetY = Math.max(offsetY, marginMinY - point.y);
                }
                if (point.y > marginMaxY) {
                    offsetY = Math.min(offsetY, marginMaxY - point.y);
                }
            });

            // Aplicar desplazamientos si es necesario
            if (offsetX !== 0 || offsetY !== 0) {
                obj.left += offsetX;
                obj.top += offsetY;
                obj.setCoords(); // Actualiza las coordenadas después de ajustar la posición
            }
        });

        function bringToFront(options) {
            options.target.bringToFront();
        }

        canvas.on('object:scaling', function (e) {
            let obj = e.target;
            let desiredObjWidth;
            let desiredObjHeight;
            let desiredScaleX;
            let desiredScaleY;
            obj.setCoords();

            // Actualizar el marcador de coordenadas
            if (obj.id && obj.id.startsWith('image-')) {
                updateCoordinateMarker(obj);
            }

            // Obtenemos el bounding rect del objeto, considerando la rotación
            let objBoundingRect = obj.getBoundingRect(true);

            let realObjectWidth = obj.width * obj.scaleX;
            let realObjectHeight = obj.height * obj.scaleY;

            let exceedsMargin = false;

            // Comparar valores previos y actuales de scaleX y scaleY
            const scaleXChanged = obj.scaleX !== obj._lastScaleX;
            const scaleYChanged = obj.scaleY !== obj._lastScaleY;

            // Verificamos si el objeto excede los márgenes

            let objBoundingBottom = (objBoundingRect.top + objBoundingRect.height);

            let marginRight = (marginRect.left + marginRect.width);
            let marginBottom = (marginRect.top + marginRect.height);

            let esquinaArribaIzquierda = obj.aCoords.tl;
            let esquinaArribaDerecha = obj.aCoords.tr;
            let esquinaAbajoIzquierda = obj.aCoords.bl;
            let esquinaAbajoDerecha = obj.aCoords.br;

            // left
            if (objBoundingRect.left < marginRect.left) {
                console.log("Left");

                // Restauramos la escala anterior válida
                obj.scaleX = obj._lastScaleX || obj.scaleX;
                obj.scaleY = obj._lastScaleY || obj.scaleY;

                exceedsMargin = true;
            }
            // top
            if (objBoundingRect.top < marginRect.top) {
                console.log("Top");

                // Restauramos la escala anterior válida
                obj.scaleX = obj._lastScaleX || obj.scaleX;
                obj.scaleY = obj._lastScaleY || obj.scaleY;

                exceedsMargin = true;
            }
            // esquinaArribaDerecha supera el margen derecho
            if (esquinaArribaDerecha.x > marginRight) {

                if (obj.angle >= 0 && obj.angle < 90) {
                    if (scaleXChanged && scaleYChanged) {
                        // Cuando se está escalando horizontal y verticalmente

                        console.log("esquinaArribaDerecha supera el margen derecho escalando horizontal y verticalmente");

                        // hallar angulo de la diagonal del objeto

                        let diagAngle  = Math.atan(realObjectHeight / realObjectWidth);

                        let xOffset = esquinaArribaDerecha.x - marginRight;

                        let yOffset = xOffset * Math.tan(diagAngle - degToRad(obj.angle));

                        xCollision = Math.abs(esquinaArribaDerecha.x - xOffset);

                        yCollision = Math.abs(esquinaArribaDerecha.y + yOffset);

                        createCoordinateMarker(xCollision, yCollision, 'green', 'collision');

                        //obj.top = esquinaArribaIzquierda.y + xOffset;

                        //obj.left = esquinaArribaIzquierda.x - yOffset;

                        //createCoordinateMarker(obj.left, obj.top, 'green', 'collision');

                    } else if (scaleXChanged) {

                        console.log("esquinaArribaDerecha supera el margen derecho escalando horizontalmente");

                        desiredObjWidth = (marginRight - esquinaArribaIzquierda.x) / Math.cos(degToRad(obj.angle));

                        desiredScaleX = desiredObjWidth / obj.width;

                        obj.scaleX = desiredScaleX;

                        //obj.scaleY = obj.scaleY;

                        obj.left = esquinaArribaIzquierda.x;
                        obj.top = esquinaArribaIzquierda.y;

                    } else if (scaleYChanged) {

                        console.log("esquinaArribaDerecha supera el margen derecho escalando verticalmente");

                        let desiredObjHeight = (marginRight - esquinaAbajoDerecha.x) / Math.sin(degToRad(obj.angle));

                        let desiredScaleY = desiredObjHeight / obj.height;

                        obj.scaleY = desiredScaleY;

                        //obj.scaleX = obj.scaleX;

                        // Calculo del punto top y left 

                        // Primero calculo del punto deseado de Top Right

                        let TR_x = marginRight;

                        let ca = desiredObjHeight * Math.cos(degToRad(obj.angle));

                        let TR_y = esquinaAbajoDerecha.y - ca;

                        // Segundo calculo del punto deseado de Top Left

                        let top_ca = realObjectWidth * Math.cos(degToRad(obj.angle));

                        let TL_x = TR_x - top_ca;

                        let top_co = realObjectWidth * Math.sin(degToRad(obj.angle));

                        let TL_y = TR_y - top_co;

                        obj.left = TL_x;
                        obj.top = TL_y;

                    }
                }

            }

            if (esquinaAbajoDerecha.x > marginRight) {
                console.log("esquinaAbajoDerecha supera el margen derecho");

                if (obj.angle >= 270 && obj.angle < 360) {
                    desiredObjWidth = (marginRight - esquinaAbajoIzquierda.x) / Math.cos((360 - obj.angle) * Math.PI / 180);

                    desiredScaleX = desiredObjWidth / obj.width;

                    obj.scaleX = desiredScaleX;
                }

                obj.scaleY = obj._lastScaleY || obj.scaleY;

                exceedsMargin = true;
            }


            // bottom
            if (objBoundingBottom > marginBottom) {
                console.log("Bottom");

                // Restauramos la escala anterior válida
                obj.scaleX = obj._lastScaleX || obj.scaleX;
                obj.scaleY = obj._lastScaleY || obj.scaleY;

                exceedsMargin = true;
            }

            if (exceedsMargin) {

                // Restauramos la posición anterior válida
                obj.left = obj._lastLeft || obj.left;
                obj.top = obj._lastTop || obj.top;

                obj.setCoords();
            } else {
                // Guardamos la escala y posición válidas
                obj._lastScaleX = obj.scaleX;
                obj._lastScaleY = obj.scaleY;
                obj._lastLeft = obj.left;
                obj._lastTop = obj.top;
            }

            canvas.renderAll();
        });

        canvas.on('object:rotating', function (e) {
            let obj = e.target;
            obj.setCoords(); // Actualiza las coordenadas del objeto

            // Actualizar el marcador de coordenadas
            if (obj.id && obj.id.startsWith('image-')) {
                updateCoordinateMarker(obj);
            }
        });

        function rotateImage(deg) {
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                activeObject.rotate((activeObject.angle + deg) % 360);
                activeObject.setCoords();

                // Actualizar marcadores de coordenadas después de rotar
                updateCoordinateMarker(activeObject);

                canvas.renderAll();
            }
        }

        resizeCanvas('carta');
    </script>
</body>

</html>
