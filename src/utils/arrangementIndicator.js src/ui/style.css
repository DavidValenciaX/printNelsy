import { getArrangementDisplayConfig, ARRANGEMENT_DISPLAY_CONFIG, ARRANGEMENT_STATUS } from './arrangementConstants.js';

/**
 * ArrangementIndicator class manages the visual representation of arrangement statuses.
 */
class ArrangementIndicator {
  constructor(domManager) {
    this.domManager = domManager;
    this.currentStatus = ARRANGEMENT_STATUS.NONE;
    this.indicatorElements = {};
    this.isInitialized = false;
  }

  /**
   * Initializes the arrangement indicators, creating them in the DOM.
   */
  initialize() {
    if (this.isInitialized) return;

    const container = this.domManager.get('arrangementIndicatorsContainer');
    if (!container) {
      console.warn('ArrangementIndicator: Container element not found');
      return;
    }

    // Clear any existing content
    container.innerHTML = '';

    // Create an indicator for each status
    for (const status in ARRANGEMENT_DISPLAY_CONFIG) {
      const config = ARRANGEMENT_DISPLAY_CONFIG[status];
      const indicatorEl = this.createIndicatorElement(status, config);
      container.appendChild(indicatorEl);
      this.indicatorElements[status] = indicatorEl;
    }
    
    this.updateStatus(this.currentStatus); // Set initial state
    this.isInitialized = true;
  }
  
  /**
   * Creates a single indicator element.
   * @param {string} status - The arrangement status.
   * @param {object} config - The display configuration for the status.
   * @returns {HTMLElement} The created indicator element.
   */
  createIndicatorElement(status, config) {
    const item = document.createElement('div');
    item.className = 'arrangement-indicator-item';
    item.dataset.status = status;
    item.title = config.description;

    const icon = document.createElement('i');
    icon.className = `${config.icon} indicator-icon`;
    
    const text = document.createElement('span');
    text.className = 'indicator-text';
    text.textContent = config.name;
    
    item.appendChild(icon);
    item.appendChild(text);

    item.style.setProperty('--indicator-color', config.color);

    return item;
  }

  /**
   * Updates the visual state of all indicators.
   * @param {string} newStatus - The new active arrangement status.
   */
  updateStatus(newStatus) {
    if (!this.isInitialized) {
      console.warn('ArrangementIndicator: Not initialized. Call initialize() first.');
      return;
    }
    
    this.currentStatus = newStatus;

    for (const status in this.indicatorElements) {
      const element = this.indicatorElements[status];
      const config = ARRANGEMENT_DISPLAY_CONFIG[status];
      
      if (status === newStatus) {
        element.classList.add('active');
        element.classList.remove('inactive');
        element.style.setProperty('--indicator-color', config.color);
      } else {
        element.classList.add('inactive');
        element.classList.remove('active');
        element.style.setProperty('--indicator-color', '#6c757d'); // Default color for inactive
      }
    }
  }

  /**
   * Gets the current arrangement status.
   * @returns {string} The current status.
   */
  getCurrentStatus() {
    return this.currentStatus;
  }

  /**
   * Shows or hides the entire indicator container.
   * @param {boolean} show - True to show, false to hide.
   */
  setVisibility(show) {
    const container = this.domManager.get('arrangementIndicatorsContainer');
    if (container) {
      container.style.display = show ? 'flex' : 'none';
    }
  }
}

.arrangement-indicator-item.active {
  border-color: var(--indicator-color, #6c757d);
  background-color: #e9ecef;
  font-weight: bold;
  color: var(--indicator-color, #212529);
}

.indicator-icon {
  font-size: 1rem;
  width: 1.25em;
  text-align: center;
}

.arrangement-indicator-item .indicator-text {
  font-size: 0.875rem;
} 